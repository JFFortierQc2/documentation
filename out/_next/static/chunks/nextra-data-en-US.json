{"/_app":{"title":" App","data":{"":""}},"/cloud/admin-dashboard/analytics":{"title":"Chatbot Analytics","data":{"":"Analytics is available only for an activated bot, it holds infromation about\nthe usage and performance of your bot. Analytics tab is per bot and it shows a dashboard that holds graphs, numbers and indexes\nabout for the selected period.","selected-period#Selected Period":"You can change the selected period to focus on specific period details. By default it is set for the past week, you are still able to change it.","1-total-users#1. Total Users":"The absolute total number of users during the selected period. Next to it an index that show the percentage of increase/decrease in the total users using the chatbot compared to previous priod(s).","2-new-users#2. New users":"The absolute number of new users during the selected period. Next to it an index that show the percentage of increase/decrease in the new users using the chatbot compared to previous priod(s).","3-returning-users#3. Returning Users":"The absolute number of returning users during the selected period. Next to it an index that show the percentage of increase/decrease in the returning users using the chatbot compared to previous priod(s).","4-session#4. Session":"The absolute number of session/conversations opened with the chatbot during the selected period. Next to it an index that show the percentage of increase/decrease in the number of the opened sessios compared to previous priod(s).","5-messages#5. Messages":"The absolute number of messages sent to the chatbot during the selected period. Next to it an index that show the percentage of increase/decrease in the number of the messages sent to the chatbot compared to previous priod(s).","6-overall-dashboard#6. Overall Dashboard":"This graph shows the relation between users, sessions and messages over a period of time."}},"/api-documentation/api-documentation":{"title":"API Documentation","data":{"":""}},"/cloud/admin-dashboard/config-variables":{"title":"Configuration Variables","data":{"":"Configuration Variables are containers that store essential information such as API keys and database credentials, and allow\nchatbot developers to easily access and modify them as needed. They provide a central location for configuration settings,\nwhich helps developers ensure that the chatbot functions correctly and stays up-to-date. Configuration variables also provide\na level of security by keeping sensitive information separate from the codebase, reducing the risk of data exposure.\nNote\nConfiguration Values set in Botpress Studio are for Development environment\nand Values set in Cloud Dashboard are for Production environment.","steps-for-using-configuration-variables#Steps for using Configuration Variables":"","1-env-keys-in-development#1. Env keys in Development":"On the Left Panel in your Botpress Studio, Click the ⚙️ icon to open up Chatbot Settings and go to Variables. You will see an option to add Configuration Variables.\nCreate a new Key and add the value that you want to use in your Development environment. Note that this value will should only be used while testing.\nClick save and publish your chatbot.","2-using-in-workflows#2. Using in workflows":"You can use {{env.key}} to get the value of the Configuration Variable Key that you've created in step 1.To use it in an Execute Code Card, you can write env.key to access it's value.","3-env-keys-in-production#3. Env keys in Production":"Go to Admin Dashboard, Select your chatbot and go to Configuration Variables tab. You can now set your key's production value here.By following these steps, you can ensure that your chatbot has access to the necessary configuration variables in both your\ndevelopment and production environments. This can help to ensure that your chatbot functions properly and is able to provide\nthe best possible user experience."}},"/cloud/admin-dashboard/chat":{"title":"Chat with your Bot","data":{"":"The Chat tab is a key feature in the cloud dashboard of your chatbot development platform. Once you have finished building and publishing your chatbot, you can use the Chat tab to test its functionality and ensure that it is working as intended.In the Chat tab, you will be able to interact with your chatbot in a simulated chat environment. This means that you can enter text or other input as if you were a user talking to the chatbot. Your chatbot will then respond with its programmed responses, allowing you to see how it works in real-time.One of the benefits of using the Chat tab is that it provides a quick and easy way to test your chatbot without having to go through the process of publishing it to a separate testing environment or deploying it to a live website or messaging platform. This can save you a lot of time and effort in the development process, allowing you to fine-tune your chatbot's responses and functionality before releasing it to your audience.Overall, the Chat tab is an essential tool for chatbot developers, providing a convenient way to test and refine your chatbot's performance and ensure that it is ready to be deployed to the real world."}},"/cloud/admin-dashboard/details":{"title":"Chatbot Details","data":{"":"","internal-name#Internal Name":"This is the internal name of the chatbot in this workspace, to be displayed for administrative purposes only. The end user will never see this name.If you want to change the name, you can click on the Edit button next to it and enter a new name.","created#Created":"Date when you first created your chatbot. This is helpful to know when you're trying to keep track of how long you've been working on your chatbot or if you need to provide this information to someone else.","last-modified#Last modified":"Date when you last made changes to your chatbot. This can be helpful to keep track of when you last made updates to your chatbot.","last-published#Last published":"Date when you last published your chatbot. When you publish your chatbot, it means that you're making the latest version of your chatbot available to your users. This is important because if you make changes to your chatbot but don't publish them, your users won't be able to see them. Knowing when you last published your chatbot can help you keep track of how up-to-date your chatbot is.","delete-chatbot#Delete Chatbot":"The Delete Chatbot button allows you to delete your chatbot permanently. This option is useful if you no longer need your chatbot and want to free up space for new chatbots on your workspace.\nDelete Chatbot\nThis action is irreversible, and all data associated with the chatbot will be\nerased."}},"/cloud/admin-dashboard/logs":{"title":"Admin Logs","data":{"":"To add logging to your Botpress chatbot, you can follow these steps:\nOpen your Botpress studio and select a Flow.\nAdd a new Execute Code Card to your flow by selecting it from the Toolbox and dragging it to the appropriate location.\nInside the Execute Code Card, add the following code:\n\n\n\n\nSave your changes and publish your chatbot to the cloud.\nNavigate to your cloud dashboard and select your published chatbot.\nOpen the Chat tab in the menu and start a conversation with your chatbot.\nOnce you have completed the conversation, switch to the Logs tab to view the logs generated by your chatbot.\n\nThe console.log() function is used to log information to the Botpress logs.You can customize this message to include any information that you need to log, such as user input or API responses.By adding logging to your chatbot, you can get a better understanding of how your bot is behaving and identify any issues that need to be addressed.This can help you to create a more effective and reliable chatbot that provides a better experience for your users."}},"/cloud/admin-dashboard/managing-workspaces":{"title":"Managing Workspaces","data":{"":"A Workspace is a collaborative environment where users can create, manage, and deploy chatbots. It provides a centralized location for managing all aspects of a chatbot project.","collaborators#Collaborators":"You can manage users in a workspace by accessing the Collaborators tab on the dashboard. From there, you can add new users to the workspace using their email addresses. The following are the six roles available for users in a workspace:\nViewer: This role allows users to view the chatbots in the workspace but not make any changes to them.\nBilling Manager: Users with this role can view and modify the billing information of the workspace.\nDeveloper: This role allows users to create, view, and update chatbots in the workspace. They can only delete the chatbots they created.\nManager: Users with this role can create, view, update, and delete all chatbots in the workspace. They can also view audit records and view/change billing information.\nAdministrator: This role allows users to add/remove workspace collaborators, create and manage all chatbots in the workspace, view audit records, and view/change billing information.\nOwner: The user who creates a workspace automatically becomes the owner of the workspace. The owner has all the privileges of Administrator and is the only one who can delete the workspace.\n\nThe user who creates a workspace automatically becomes the owner of the workspace.","billing-in-botpress#Billing in Botpress":"Botpress offers both Community and Business plans, and you can view your billing details by accessing the billing section on the dashboard.","current-plan#Current Plan":"In the billing section, you can see your current plan, whether it is the Community or Business plan. If you are on the Business plan, you will also see the pricing for it. You can find more information about the pricing plans on the Botpress website: https://botpress.com/pricing.","current-monthly-bill-and-next-payment-date#Current Monthly Bill and Next Payment Date":"You can view your current monthly bill and the next payment date in the billing section. The current monthly bill is the amount that you will be charged on the next payment date.","payment-information#Payment Information":"In the billing section, you can also view the payment method that you are using for your Botpress account.","messages#Messages":"The Messages section displays the number of incoming messages you have received, as well as how far you are from reaching your limit.","monthly-budget#Monthly Budget":"The monthly budget allows you to set a limit on your billing amount to ensure that you are not charged more than the amount you pre-establish.","invoice#Invoice":"Finally, you can view your past payments in the Invoice section of the billing page.In summary, the billing section of Botpress allows you to keep track of your current plan, current monthly bill, payment information, incoming messages, monthly budget, and past payments.","audits#Audits":"Audits show the history of important events in a Workspace, such as changes to bots, collaborators, and configuration. They provide a way to track and review the changes made to a Workspace. They are useful for understanding who did what and when, especially in collaborative environments where multiple people work in the same Workspace.Audits capture events related to bots, collaborators, and configuration changes. Each audit event has a timestamp, an action type (added, removed, published, updated, deleted, downloaded), and the email address of the user who performed the action.You will see a list of audit events, with the most recent ones at the top. You can use the search box to filter the events by email address, action type, or date range.By reviewing audits, you can understand who did what and when, which is useful for accountability, troubleshooting, and collaboration.","workspace-settings#Workspace Settings":"Here, you can view and update information such as the Workspace name, Owner, and Billing plan.","workspace-name#Workspace Name":"The Workspace Name section displays the name of your Workspace. To update the Workspace name, click on the Edit button next to the current name, make your changes, and click Save.","workspace-owner#Workspace Owner":"The Workspace Owner section displays the email address of the user who created the workspace.","billing-plan#Billing Plan":"The Billing Plan section displays the current billing plan of your workspace. To upgrade to a higher plan, click the Upgrade to Business Plan button and follow the instructions.","delete-workspace#Delete Workspace":"The Delete Workspace section allows you to delete your workspace permanently. You must be the owner of the Workspace to do so.\nDeleting a Workspace\nThis is an irreversible process and will permanently erase all data associated\nwith your workspace, including bots, conversations, and analytics.\nTo proceed with the deletion, click on the Delete Workspace button and confirm your decision.Before deleting your workspace, we recommend downloading your invoices from the Billing section to ensure you have a record of all charges and payments associated with your workspace.","leaving-a-workspace#Leaving a Workspace":"If you want to leave a workspace, you can access the workspace settings and click Leave Workspace. This will remove you from the list of collaborators for the workspace. Note that if you are the owner of the workspace, you cannot leave your workspace."}},"/cloud/channels/gmail":{"title":"Gmail","data":{"":"","documentation-coming-soon#Documentation Coming Soon":""}},"/cloud/admin-dashboard/messaging-channels":{"title":"Messaging Channels","data":{"":"Botpress allows you to easily integrate your chatbot with various messaging channels, so that you can reach your users on their preferred platforms. Here are the steps to integrate your chatbot with a messaging channel:\nPublish your Chatbot from the Botpress Studio for enabling your bot to be able to connect with different messaging channels.\nNavigate to the Channels tab in your Botpress Admin's Chatbot Settings.\nSelect the Messaging Channel that you want to integrate with from the list of available options. For example, if you want to integrate with Facebook Messenger, click on the Messenger.\nFollow the instructions provided for the selected channel to set up the integration. This will typically involve creating an account on the channel's platform, generating an access token or API key, and configuring the integration settings in Botpress.\n\nClick on the following links to know more about each channel integration.\nMessenger\nSlack\nSunCo\nTeams\nTelegram\nTwilio\nVonage\nWebchat\nWhatsApp\nLINE\nViber\nInstagram\n\nBy integrating your chatbot with multiple messaging channels, you can expand your reach and engage with your users wherever they are. This can help you to provide a more convenient and personalized experience for your users, which can lead to increased satisfaction and loyalty."}},"/cloud/channels/instagram":{"title":"Instagram","data":{"":"","requirements#Requirements":"You will need a Facebook app and a Facebook page to connect you bot to messenger.","enabling-instagram-in-botpress-cloud-dashboard#Enabling Instagram in Botpress Cloud Dashboard":"Go to the chatbot settings in your cloud dashboard and enable Instagram. We will get the APP ID, App Secret, Verify Token, Page ID and Access Token from the following steps.","create-a-facebook-app#Create a Facebook App":"To create a Facebook App,\nlog in to your Facebook account and go to the Facebook for Developers website.\nSelect My Apps from the top menu, and create a new app.\nSelect Business as App Type.\nGive a name to your App.\nAdd Instagram Graph API to your App.\nFor more details and assistance, visit the Facebook developer documentation.","create-a-facebook-page#Create a Facebook Page":"If you do not already have a Facebook page you will need to create one. You can find details on how to create a new Facebook page here. To link your chatbot to a pre-existing page, you must have an administrator or developer role.\nGive a name to your Facebook Page.\nPick a Category.","channel-configuration#Channel Configuration":"","api-version#API version":"The messenger channel is made to interact with version 12.0 or higher of the Messenger API. It is not the default version so it must be changed in your app's settings\nGo to your Facebook App.\nIn the left sidebar, expand the Settings menu and select Advanced.\nIn the Upgrade API version section, select v12.0 or higher as the API version.\nClick on Save Changes.","add-messenger-product#Add Messenger Product":"Messenger is not added by default in your Facebook App, so it must be added manually.\nIn the left sidebar, click on Add Product.\nIn the Facebook Messenger section click Set Up.","app-id-and-secret#App ID and Secret":"The App ID and Secret are used to validate webhook requests.\nIn the left sidebar, expand the Settings menu and select Basic. Here you can find the App ID and App Secret.\nClick on the Show button in the App Secret text box. Copy the App Id and App Secret to your channel configuration.","page-id-and-access-token#Page ID and Access Token":"The page ID and Access Token are used to send messages to the Messenger API.\nIn the left sidebar, expand the Messenger menu and select Instagram Settings\nIn the Access Tokens section, click Add or Remove Pages and add you Facebook page.\nCopy the number under you page name and paste it in you Page ID channel configuration.\nClick on Generate Token. Copy this token and paste it in the Access Token channel configuration.","verify-token#Verify Token":"The Verify Token is used by Facebook to verify that you are the real owner of the provided webhook.You can generate any random alphanumerical string for this configuration. Paste it in your Verify Token channel configuration.","save-configuration#Save Configuration":"Channel configuration is completed, you can now click Save. It is important you save your configuration before configuring the webhook, otherwise Messenger will be unable to validate the webhook URL.","webhook-configuration#Webhook Configuration":"To receive messages from Messenger, you will need to setup a webhook.\nGo to your Facebook App.\nIn the left sidebar, expand the Messenger menu and select Settings.\nIn the Webhooks section, click Add Callback URL.\nCopy and paste the webhook URL provided in the channel configuration UI.\nCopy and paste the Verify Token you generated earlier.\nClick on Verify and Save. Make sure your channel configuration was saved before doing this step, otherwise the webhook validation will fail.\nClick on Add subscriptions and add messages, instagram_manage_messages and messaging_postbacks to your webhook."}},"/cloud/channels/line":{"title":"Line","data":{"":"","requirements#Requirements":"You will need to create a channel on the LINE Developers Console, and then add that channel to your LINE official account.","create-a-meta-app--business-account#Create a Meta App & Business Account":"To create a channel and add it to your official account, you can read the Getting started with the Messaging API. The next step is configuring the Messaging API Webhook Settings.When you have created everything and are ready for the next step, go to the next section.","channel-configuration#Channel Configuration":"To add LINE integration configuration, go to your bot's configuration screen. Then go to the channel tab, and click on LINE.A screen will pop up asking for the following details:","1-channel-access-token#1. Channel Access Token":"The Channel Access Token is the means of authentication for the channel. You are deemed to have permission to use the channel if the Access Token is correct.To get the Channel Access Token: in your channel configuration, open the Messaging API tab, scroll to the bottom to the Channel Access Token section, and then generate a new one or copy it if the Channel access token was already issued.For Long-Lived Channel Access Token: read this LINE documentation.","2-channel-secret#2. Channel Secret":"The Channel Secret is used to verify the signature between LINE and Botpress.To get the Channel Secret: in your channel configuration, open the Basic settings tab, scroll to the bottom to the Channel Secret section, and then copy the secret.","finalizing-channel-configuration#Finalizing Channel Configuration":"The next step is to Enable the channel from the top of the screen and copy the webhook URL from the button below the webhook URL. Then click Save.Now, we proceed to the last step by setting your webhook URL in LINE.","content-types-mapping#Content Types Mapping":"","from-botpress-to-line#From Botpress to LINE":"Text is mapped to Text Object\nText with Markdown is mapped to Text Object\nImage is mapped to Image Object\nAudio is mapped to Audio Object\nVideo is mapped to Video Object\nFile is NOT supported in LINE Message Types\nLocation is mapped to Location Object\nCarousel is mapped to Flex Object\nCard is mapped to Flex Object\nDropdown is mapped to Flex Object\nChoice is mapped to Flex Object","from-line-to-botpress#From LINE to Botpress":"Text is mapped to Text Object\nThe rest of the types are not currently processed by Botpress"}},"/cloud/channels/messenger":{"title":"Messenger","data":{"":"","requirements#Requirements":"You will need a Facebook app and a Facebook page to connect you bot to messenger","enabling-messenger-in-botpress-cloud-dashboard#Enabling Messenger in Botpress Cloud Dashboard":"Go to the chatbot settings in your cloud dashboard and enable messenger. We will get the APP ID, App Secret, Verify Token, Page ID and Access Token from the following steps.","create-a-facebook-app#Create a Facebook App":"To create a Facebook App, log in to your Facebook account and go to the Facebook for Developers website. Select My Apps from the top menu, and create a new app. For more details and assistance, visit the Facebook developer documentation","create-a-facebook-page#Create a Facebook Page":"If you do not already have a Facebook page you will need to create one. You can find details on how to create a new Facebook page hereTo link your chatbot to a pre-existing page, you must have an administrator or developer role","channel-configuration#Channel Configuration":"","api-version#API version":"The messenger channel is made to interact with version 12.0 or higher of the Messenger API. It is not the default version so it must be changed in your app's settings\nGo to your Facebook App\nIn the left sidebar, expand the Settings menu and select Advanced\nIn the Upgrade API version section, select v12.0 or higher as the API version\nClick on Save changes","add-messenger-product#Add Messenger Product":"Messenger is not added by default in your Facebook App, so it must be added manually\nIn the left sidebar, click on Add Product\nIn the Facebook Messenger section click Set Up","app-id-and-secret#App Id and Secret":"The app id and secret are used to validate webhook requests\nIn the left sidebar, expand the Settings menu and select Basic. Here you can find the App ID and App Secret\nClick on the Show button in the App Secret text box. Copy the App Id and App Secret to your channel configuration","page-id-and-access-token#Page Id and Access Token":"The page id and access token are used to send messages to the Messenger API\nIn the left sidebar, expand the Messenger menu and select Settings\nIn the Access Tokens section, click Add or remove Pages and add you facebook page\nCopy the number under you page name and paste it in you Page Id channel configuration\nClick on Generate token. Copy this token and paste it in the Access Token channel configuration","verify-token#Verify Token":"The verify token is used by facebook to verify that you are the real owner of the provided webhookYou can generate any random alphanumerical string for this configuration. Paste it in your Verify Token channel configuration","save-configuration#Save Configuration":"Channel configuration is complete, you can now click Save. It is important you save your configuration before configuring the webhook, otherwise Messenger will be unable to validate the webhook url","webhook-configuration#Webhook Configuration":"To receive messages from Messenger, you will need to setup a webhook\nGo to your Facebook App.\nIn the left sidebar, expand the Messenger menu and select Settings\nIn the Webhooks section, click Add Callback URL\nCopy paste the webhook url provided in the channel configuration UI\nCopy paste the verify token you generated earlier\nClick on Verify and save. Make sure your channel configuration was saved before doing this step, otherwise the webhook validation will fail\nClick on Add subscriptions and add messages and messaging_postbacks to your webhook"}},"/cloud/channels/slack":{"title":"Slack","data":{"":"","requirements#Requirements":"","create-a-slack-app#Create a Slack App":"You will need a Slack App to connect your bot to Slack\nGo to your apps page\nClick Create new app, select From scratch then give it a name. Remember your App's name, you'll need it in a few minutes","channel-configuration#Channel Configuration":"","signing-secret#Signing Secret":"The signing secret is used to verify webhook requests\nIn the left sidebar, click on Settings > Basic Information\nScroll down to App Credentials section. Next to Signing Secret, click Show to reveal the signing secret.\nIn Botpress, copy the signing secret from the previous step in the Signing Secret box.","bot-token#Bot Token":"The bot token is used to authenticate requests made to the Slack API\nIn the left sidebar, click on Features > OAuth & Permissions\nUnder the Scope > Bot Token Scopes section, click Add an OAuth Scope. Select the chat:write option from the list.\nNear the top of the page, click on Install to Workspace in the OAuth Tokens for Your Workspace section\nIn the next screen, your app will request access to your Slack workspace. Click Allow.\nIn the OAuth & Permissions > OAuth Tokens for Your Workspace section, copy the Bot User OAuth Token.\nIn Botpress, copy the Bot User OAuth Token from the previous step in the Bot Token box.","save-configuration#Save Configuration":"Channel configuration is complete, you can now click Save. It is important you save your configuration before configuring the webhooks, otherwise Slack will be unable to validate the webhook url","webhook-configuration#Webhook Configuration":"","events-webhook#Events Webhook":"Slack sends regular events such as messages to the event webhook\nIn the left sidebar, click on Features > Event Subscriptions\nTurn on events by click the On/Off button\nCopy paste the webhook url provided in the channel configuration UI to the Request URL field\nUnder Subscribe to bot event, add message.im and message.channels\nClick the Save Changes button. Make sure your Slack channel configuration is saved before doing this step, otherwise webhook validation will fail\nA yellow banner will be displayed at the top of the screen. Click the reinstall your app link\nIn the next screen, your app will request access to your Slack workspace. Click Allow.","interactivity-webhook#Interactivity Webhook":"Slack sends \"interactive\" events such as reactions to message to the interactivity webhook\nIn the left sidebar, click on Features > Interactivity & Shortcuts\nTurn on interactivity by click the On/Off button\nCopy paste the webhook url provided in the channel configuration UI to the Request URL field\nClick the Save Changes button","install-app#Install App":"","add-app-to-workspace#Add App to Workspace":"Your Slack app needs to be added to your workspace to allow Slack users to communicate with it\nIn the left sidebar, click on Features > App Home\nScroll down and in the Show Tabs > Messages Tab section, tick Allow users to send Slash commands and messages from the messages tab\nIn Slack, under the Apps section of the sidebar, click the + Add apps button. In the search bar, type the name of your Slack app. Click on your Slack app in the search results. You can now chat with your Slack App"}},"/cloud/channels/overview":{"title":"Overview","data":{"":"Once you've published your chatbot, your next step might be to integrate it various messaging channels.","supported-content-types#Supported Content types":"","sending#Sending":"This is the list of content types we support sending to each channel.\nMessenger\tMicrosoft Teams\tSlack\tTelegram\tTwilio\tVonage\tSmooch\tText\t✔\t✔\t✔\t✔\t✔\t✔\t✔\tImage\t✔\t✔\t✔\t✔\t✔\t✔\t✔\tChoice\t✔\t✔\t✔\t✔\t✔ (choices down rendered)\t✔\t✔\tDropdown\t✔\t✔\t✔\t✔\t✔ (choices down rendered)\t✔\t✔\tCard\t✔\t✔\t✔\t✔\t✔ (buttons down rendered)\t✔ (buttons down rendered)\t✔\tCarousel\t✔\t✔\t✔\t✔\t✔ (buttons down rendered)\t✔ (buttons down rendered)\t✔\tFile\t✔ (as URL)\t✔ (as URL)\t✔ (as URL)\t✔\t✔ (as URL)\t✔\t✔\tAudio\t✔ (as URL)\t✔ (as URL)\t✔ (as URL)\t✔\t✔\t✔\t✔\tVideo\t✔ (as URL)\t✔ (as URL)\t✔ (as URL)\t✔\t✔ (as URL)\t✔\t✔\tLocation\t✔ (as Google Maps links)\t✔ (as Google Maps links)\t✔ (as Google Maps links)\t✔\t✔ (as Google Maps links)\t✔\t✔","receiving#Receiving":"This is the list of content-types we support receiving from each channel.\nMessenger\tMicrosoft Teams\tSlack\tTelegram\tTwilio\tVonage\tSmooch\tText\t✔\t✔\t✔\t✔\t✔\t✔\t✔\tQuick Reply\t✔\t✔\t✔\tN/A\t✔\t✔\tN/A\tPostback\t✔\t✔\t✔\t✔\t✔\t✔\t✔\tSay Something\t✔\t✔\t✔\t✔\t✔\t✔\t✔\tVoice\t-\t-\t-\t-\t-\t-\t-\tImage\t-\t-\t-\t-\t-\t-\t-\tFile\t-\t-\t-\t-\t-\t-\t-\tAudio\t-\t-\t-\t-\t-\t-\t-\tVideo\t-\t-\t-\t-\t-\t-\t-\tLocation\t-\t-\t-\t-\t-\t-\t-"}},"/cloud/channels/sunco":{"title":"Sunshine Conversations","data":{"":"","requirements#Requirements":"You will need a Smooch app with a channel configured before connecting Smooch to Botpress","smooch-app#Smooch App":"On the Smooch home page, click on Create new app.\nEnter a name for your app and click Create App\nConnect a channel to your app (Telegram, WhatsApp, or any other listed channel)\nYou should see a channel in the Overview section of your app","configuration#Configuration":"","app-id#App Id":"The smooch channel needs the app id to identify the smooch app when making API calls\nGo to the Settings section of your app\nYou should see an App Id section if you scroll down. Copy paste this value to the App Id channel configuration","key-id-and-key-secret#Key Id and Key Secret":"The key id and secret are needed to authenticate API calls to Smooch\nAt the bottom of to the Settings section of your app, click Generate API key\nCopy paste the id (the one that starts with app_) in the Key Id channel configuration\nCopy paste the secret in the Key Secret configuration","webhook-secret#Webhook Secret":"The webhook secret is needed to validate webhooks requests. You get a webhook secret for each webhook integration you create\nGo to the Integration section of your app\nIn the API & Webhooks section, click on Webhooks\nClick Connect, then Create a webhook\nCopy paste the webhook url provided in the UI\nSelect v2 as your webhook version\nSelect Conversation message and Postbacks in the basic triggers\nClick Create Webhook. You will see the webhook you created in the table, and the secret in the last column\nCopy paste the webhook secret in the Webhook Secret channel configuration","save-configuration#Save Configuration":"Channel configuration is complete, you can now click Save"}},"/cloud/channels/teams":{"title":"Microsoft Teams","data":{"":"","requirements#Requirements":"","configure-microsoft-account#Configure Microsoft Account":"Your Microsoft Account should have access to Azure and Teams. You can check out the Azure and Teams documentation for information on how to make these connections","channel-configuration#Channel Configuration":"","register-app#Register App":"In the Azure portal, open the App registrations page\nClick New registration, then choose a name for your application\nIn the section Supported account types, choose Accounts in any organizational directory and personal Microsoft accounts, then click Register\nCopy paste the value of Application (client) ID to the App Id channel configuration","app-password#App Password":"Click Certificates & secrets, then click New client secret, then fill in the required fields\nCopy paste the the value in the Value column to the App Secret channel configuration","save-configuration#Save Configuration":"Channel configuration is complete, you can now click Save","create-your-bot#Create Your Bot":"Navigate to the Bot Framework Registration Page\nFill the Display name and Bot handle fields with whatever value\nCopy paste you App Id to the app id field\nCopy paste the webhook url provided in the channel configuration UI to the Messaging endpoint field\nClick Register\nOn the next page (Connect to channels), under the section, Add a featured channel, click Configure Microsoft Teams Channel, then click Save"}},"/cloud/channels/telegram":{"title":"Telegram","data":{"":"","requirements#Requirements":"","create-a-bot#Create a Bot":"To create a bot on Telegram, use Telegram's BotFather. The BotFather will ask you for a name and username, then generate an authorization token for your new botThe name of your bot is displayed in contact details and elsewhereThe Username is a short name to be used in mentions and t.me links. Usernames are 5-32 characters long and are case insensitive but may only include Latin characters, numbers, and underscores. Your bot's username must end in bot, such as tetris_bot or TetrisBot","channel-configuration#Channel Configuration":"","generate-an-authorization-token#Generate an Authorization Token":"When you create a Telegram bot, Botfather will automatically generate a token. The token is a string that is required to authorize the bot and send requests to the Bot API. Keep your token secure and store it safely; anyone can use it to control your botIf your existing token is compromised or you lost it for some reason, use the /token command to generate a new one","bot-token#Bot Token":"Copy paste your telegram bot token into the Bot Token channel configuration and click Save. Webhooks will be created automatically\nCopy paste your telegram bot token into the Bot Token channel configuration and click Save. Webhooks will be created automatically"}},"/cloud/channels/viber":{"title":"Viber","data":{"":"","enabling-viber-in-botpress-cloud-dashboard#Enabling Viber in Botpress Cloud Dashboard":"Go to the chatbot settings in your cloud dashboard and enable Viber. We will get the Authentication token from the following steps.\nVisit the Viber Admin panel and click on Create a Bot Account.\nFill in the required details. Bot Avatar, Account Name, URI, Category, Subcategory, Language, Account Description, Email Address and Location.\nCopy the Authentication Token and paste it in Viber's channel settings in Botpress Cloud Dashboard.\nAdd Bot Name (required) and Bot Avatar URL (optional).\nClick Save.\nStart chatting with the bot!"}},"/cloud/channels/vonage":{"title":"Vonage","data":{"":"","requirements#Requirements":"","create-vonage-application#Create Vonage Application":"You will need a Vonage Account and a Vonage Application to connect Vonage to Botpress\nCreate a Vonage Account\nCreate a Vonage Application","channel-configuration#Channel Configuration":"","api-credentials#API credentials":"Go to your API Settings.\nCopy paste the API key to the API Key channel configuration\nCopy paste the API secret from the Account credentials section to the API Secret channel configuration\nCopy paste the signature secret from the Signed webhooks section to the Signature Secret channel configuration","save-configuration#Save Configuration":"Channel configuration is complete, you can now click Save","webhook-configuration#Webhook Configuration":"","sandbox#Sandbox":"You can use the Vonage sandbox to test you channel with WhatsApp\nCheck the Use Testing API box in your channel configuration\nGo to your Sandbox Settings\nCopy paste the webhook url provided in the channel configuration UI to the Inbound and Status fields in the Webhooks section"}},"/cloud/channels/webchat":{"title":"Web Chat","data":{"":"Make sure you've published your chatbot to Botpress Cloud.\nGo to your published chatbot in the Botpress Cloud dashboard and click on Web Chat under the Channels tab and enable it.\nCopy the Pre-configured script and paste it in the <body></body> tag of your HTML page.(Optional)\nYou can share your chatbot with people that would like to quickly test your chatbot using the Sharable Link\n\nYou can also click on the Configurable option if you want to customize the web chat configuration.Learn more about customizing your chatbot"}},"/cloud/channels/twilio":{"title":"Twilio","data":{"":"","requirements#Requirements":"Create a Twilio account and purchase a Twilio phone number","channel-configuration#Channel Configuration":"","account-sid-and-auth-token#Account SID and Auth Token":"Go to you Twilio console dashboard\nScroll down and copy your Account SID and Auth Token from the Project Info section and paste them in the Account SID and Auth Token channel configurations","save-configuration#Save Configuration":"Channel configuration is complete, you can now click Save","webhook-configuration#Webhook Configuration":"To receive messages from Twilio, you will need to setup a webhook\nClick on Explore Products in the left pannel\nClick on Messaging\nClick on Services in the left pannel\nClick on your service (if you haven't already created your service, create a messaging service and add your phone as a sender)\nClick on Sender Pool in the left pannel\nClick on your phone number\nScroll down the phone number settings page\nCopy paste the webhook url provided in the channel configuration UI to the A Message Comes In field"}},"/cloud/channels/whatsapp":{"title":"WhatsApp","data":{"":"","requirements#Requirements":"You will need a Meta app and a WhatsApp Business Account to connect your bot to WhatsApp","create-a-meta-app--business-account#Create a Meta App & Business Account":"To create a Meta App, log in to your Meta account and follow Step (1) & Step (2) in this article.Before going to Step (3), we will configure the WhatsApp channel on Botpress.","channel-configuration#Channel Configuration":"To add WhatsApp integration configuration, go to your bot’s configuration screen, then go to the channel tab, and click on WhatsApp.A screen will pop up asking for the following details:","1-verify-token#1. Verify Token":"The Verify Token is used by Meta to verify that you are the real owner of the provided webhook.You can generate any random alphanumeric string for this configuration. Paste it in your Verify Token channel configuration.","2-access-token#2. Access Token":"The Phone Number ID and Access Token are used to send and receive messages to/from the WhatsApp API.In your Meta App:\nIn the left sidebar, expand the WhatsApp menu and select Getting Started\nIn the Temporary access token section, click Copy and then paste it in the Access Token field in Botpress\n\nFor a permanent Access Token: https://developers.facebook.com/blog/post/2022/12/05/auth-tokens/","3-phone-number-id#3. Phone Number ID":"In your Meta App:\nIn the left sidebar, expand the WhatsApp menu and select Getting Started\nIn the Send and receive messages section, beside the label Phone Number ID click Copy then paste it in the Phone Number ID field in Botpress","finalizing-channel-configuration#Finalizing Channel Configuration":"The next step is to Enable the channel from the top of the screen and then copy the webhook URL from the button below the webhook URL.In the last step, click Save.Now we can go back to Step (3) & Step (4) in this article.","webhook-fields#Webhook Fields":"","we-need-to-subscribe-to-the-webhook-fields-below#We need to subscribe to the webhook fields below":"Messages: For the chat to work properly, you need to subscribe to the messages webhook field.","content-types-mapping#Content Types Mapping":"","from-botpress-to-whatsapp#From Botpress to WhatsApp":"Text is mapped to Text Object\nText with Markdown is mapped to Text Object\nImage is mapped to Media Image Object\nAudio is mapped to Media Audio Object\nVideo is mapped to Media Video Object\nFile is mapped to Media File Object\nLocation is mapped to Location Object\nCarousel is mapped to Interactive List Object\nCard is mapped to Interactive List Object\nDropdown is mapped to Interactive List Object\nChoice is mapped to Interactive Button Object","from-whatsapp-to-botpress#From WhatsApp to Botpress":"Text is mapped to Text Object\nInteractive feedbacks are mapped to Text Object.\nThe rest of the types are not currently processed by Botpress"}},"/cloud/generative-ai/ai-execute-code":{"title":"Generate code using AI","data":{"":"To use Generative AI for Execute Code, you simply provide a plain text instruction in natural language, and the AI will generate the corresponding code for you. For example, you can ask the AI to find the difference between two dates or get data from an external API and filter it based on certain criteria. The AI will then generate the code needed to perform these tasks, which you can use in your bot.Additionally, you can also build your own code using the Axios, Lodash, and Moment Luxon node packages. This allows you to perform more complex tasks or execute code that is specific to your needs.Overall, Generative AI using Execute Code makes it easier to perform a wide range of tasks within your bot, without the need for extensive coding knowledge."}},"/cloud/generative-ai/ai-task-card":{"title":"AI Task Card","data":{"":"The AI Task Card is part of the Toolbox in Botpress for generating content using artificial intelligence to automate various tasks.\nTo use the AI Task Card, users must provide clear instructions and specific inputs, and define well-named variables.\nThe Task Instructions parameter is used to provide a detailed description of the task, including any relevant constraints or guidelines.\nThe AI Task Input is the problem subject provided to the AI engine, and should be as specific as possible for more accurate and relevant content generation.\nUsers can store the extracted information in variables within Botpress and choose variable names that are easy to understand and identify.\nThe Task Example allows users to provide examples of text input and generated outputs to help the AI Task better understand the instructions and output format."}},"/cloud/generative-ai/ai-transitions":{"title":"AI Based Transitions","data":{"":"AI Transitions are a feature that allows you to create transitions in plain language so that your chatbot responds to users’ inputs as you want it to.For example, let's say you have a chatbot that helps customers with their online orders. You could use an AI Transition to create a condition that recognizes when a customer asks about the status of their order.Here's an example of a transition command in plain language.\n\nWith this command, the AI Transition will write the necessary code for your chatbot to recognize when a customer asks about their order status and transition them to the appropriate information.This feature provides a lot of flexibility for creating a chatbot that can understand and respond to a wide variety of questions and statements. And you don’t need to be a developer to use it - you can simply write out the commands in plain language and the chatbot will do the rest!"}},"/cloud/generative-ai/ai-prompt-chaining":{"title":"AI Prompt Chaining","data":{"":"AI Prompt Chaining is a technique of connecting multiple AI Task Cards to generate complex content by breaking down a large generative task into smaller, more manageable pieces.\nPractical examples of prompt chaining are generating product descriptions, creating personalized email campaigns, and generating complex chatbot responses.\nPrompt chaining improves the accuracy and relevance of generated content by optimizing each AI Task Card to perform a specific task, and using the output of one as input for the next.\nGuidelines and best practices for prompt chaining in Botpress include breaking down large tasks into smaller ones, testing each AI Task Card individually, formatting the output correctly, and using appropriate variable names."}},"/cloud/generative-ai/best-practices":{"title":"Best Practices","data":{"":"","dos-and-donts#Do's and Dont's":"In general, the AI Task, Execute Code, and the transition don't know what is happening in the rest of the flow. Each is concerned only with itself. To get the best results with AI, these are the words to use and the words to stay away from:","dos---use-effective-phrasing#Do's - Use Effective phrasing:":"\"What is the capital of France?\"\n\"Can you tell me about the history of the Great Wall of China?\"\n\"Please provide a definition of the word 'algorithm.'\"\nUse absolutes, words like: “ignore”, “add”, “extract”, “use”, “store”, etc.","donts---use-ineffective-phrasing#Dont's - Use Ineffective phrasing:":"\"Don't tell me the wrong answer.\"\n\"I'm not interested in hearing your opinion.\"\n\"You wouldn't happen to know what I'm talking about, would you?\"\nDon't use hedge words like: “maybe”, “try”, \"potentially\", \"avoid\", etc.","personality-tone-language#Personality, Tone, Language":"You can set the personality, tone, and language of your bot using simple natural words.","personality#Personality":"Words such as act like, pretend, and sound like can influence the AI to act like a celebrity or to sound like a person from specific profession can have a great effect on the users who use your bot.\n\nFor example, you can use \"Act like Kevin Hart\"Or \"Act like a Teacher\"","tone#Tone":"Phrases starting with \"use emojis\", \"be extra friendly\" or \"be empathetic\" can influence the AI by showing emotions in its text.For example, you can use \"sound like a loving mum who is fond of babies\"We can also mix that with \"Use a lot of emojis\"","language#Language":"You can also instruct your bot to answer or speak in a specific language using \"speak in\", \"use language\" and \"answer using\"","input-and-output#Input and Output":"What words can we use to direct the AI to our inputs and outputs effectively? These are just guidelines, so feel free to be as creative as you want.","input-sample#Input Sample":"We can use a phrase like Taking the user's input into consideration, and in the input, we can specify exactly what each input means.For example - the AI Task Instruction could be:\n\nAnd the AI Input will be:\n\nWe can also direct it to where it will find the information and in which variable like in the variable, and then mention the variable name.For example - the AI Task Instruction could be:\n\nAnd the AI Input will be:","output-sample#Output Sample":"We can use words like store and into to direct it to store the extracted value into a specific variable.For example - the AI Task Instruction could be:\n\nAnd the output will be stored in a Variable named whatDoYouThink","example---preserving-context#Example - Preserving Context":"To ensure that the AI knows the context and keeps it into its consideration, we will need to do a couple of things.","step-1-saving-context#Step 1: Saving context":"For this step, we can use an Execute code to append everything related to the context to a string variable:So every time the user says something, it is concatenated/append to what they said before","step-2-pass-it-to-ai-input#Step 2: Pass it to AI Input":"In the AI Task, we can pass that variable as an input, then direct the AI to consider it using a statement like Take into consideration the user history.","the-result#The Result":"In the end, we can ask multiple questions while making sure the AI takes into consideration the history of the conversation.You can also pass the past answers from the AI and direct it to Use new answers every time. This way you can achieve AI Prompt Chaining.","limitations#Limitations":"","token-limitation#Token Limitation":"The current limitation is 5000 characters, and we are working to increase it.You can find more information here: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them","understanding-limitation#Understanding Limitation":"There are limitations to what the AI can understand, such as complex or nuanced language involving sarcasm, irony, or figurative expressions.","time-limitation#Time Limitation":"Since the AI is based on ChatGPT models, you must know that ChatGPT is not connected to the internet, and it can occasionally produce incorrect answers. It has limited knowledge of the world and events that happened after 2021 and may also occasionally produce harmful instructions or biased content.You can find more information here: https://help.openai.com/en/articles/6783457-chatgpt-general-faq","conclusion#Conclusion":"Generally, it's best to avoid negative and vague language or ambiguous statements when using AI-related tasks. Instead, always try to be specific and direct, and use a language that is easy to understand.It is better to use natural language; you can use a wide range of inputs, including commands and requests. AI doesn't have human emotions; it may not fully understand some complex or nuanced language, especially if it involves sarcasm, irony, or figurative expressions."}},"/cloud/generative-ai/chatbot-personality":{"title":"Chatbot Personality","data":{"":"","steps-for-customizing-your-chatbots-personality#Steps for Customizing your Chatbot's Personality":"Open Botpress Studio and click on the Botpress Icon located at the top-left corner.\nSelect Chatbot Settings from the dropdown menu.\nEnable Personality Rewrite and add a description of the personality you want your bot to embody.\nSpecify the tone you want your chatbot to convey, for example, \"friendly but professional\".\nDecide how often you want to use emojis, if at all.\nConsider the context in which the bot will be used and adjust the personality accordingly. For example, if the bot is for a tech startup, the personality might be dynamic and forward-thinking.\nTest the bot's personality to ensure it aligns with your brand and effectively engages with users."}},"/cloud/getting-started/bot-templates":{"title":"Bot Templates","data":{"":"Bot templates are pre-configured bot projects that contain predefined conversational flows, Knowledge Bases, and responses.They serve as a starting point for building bots and can be customized to suit specific use cases. Botpress provides a collection of built-in templates that cover various scenarios, such as Recipe Bot, Recruitment Bot, AI Public Personality Bot, Cinema Booking and much more!These templates can be used as-is or modified according to the specific requirements of your chatbot.","benefits-of-using-bot-templates#Benefits of Using Bot Templates":"Using bot templates in Botpress offers several advantages:\nTime-Saving: Bot templates eliminate the need to build conversational flows from scratch, saving development time and effort. Developers can focus on customizing and enhancing the template to match their desired bot behavior.\nBest Practices: Templates follow industry best practices and design patterns, ensuring that your bot benefits from proven strategies for conversation management.\nConsistency: Templates provide a consistent user experience by offering a predefined structure and logic that guide the bot's behavior.\nFlexibility: While templates offer a ready-made starting point, they can be easily customized and extended to meet specific requirements. Developers have full control over the template and can modify it as needed.","using-bot-templates#Using Bot Templates":"In Botpress Studio, click on the Botpress icon located at the top-left corner, and select Explore Bot Templates.\nChoose the template you would like to start with and click on Use Template. If you wish to start your bot building from scratch, you can select the Basic (empty) Bot Template.\nYou can publish the bot to use the template as it is, or customize it to meet your specific requirements. This includes modifying the predefined conversational flows, adding or removing knowledge bases, and updating responses. Botpress provides a visual flow editor that simplifies the customization process, enabling you to define the bot's behavior using a drag-and-drop interface.\n\n\nOverriding Template\nIf you override an existing bot with a bot template, all the previous content and configurations of your bot will be erased and replaced with the new template. It's important to note that overriding a bot with a template should be done with caution, as it will result in the loss of any existing data and configurations associated with the original bot."}},"/cloud/getting-started/create-and-publish-your-chatbot":{"title":"Create & Publish your chatbot","data":{"":"Creating a chatbot with Botpress is a simple and intuitive process that can be accomplished by both technical and non-technical users. With a few straightforward steps, you can quickly set up your chatbot and start enjoying its benefits.Botpress provides you with the tools you need to build chatbots that can perform a variety of tasks, including but not limited to:\nbooking events\nplacing orders\nwelcoming users\ndeflecting support cases\nanything you have in mind!","prerequisites#Prerequisites":"To begin building your chatbot with Botpress, you will first need to create an account. This can be accomplished by visiting the sign-up page and registering for a new account.","creating-a-bot#Creating a Bot":"Now that you've set up your account let's create a new bot.\nLog in to Botpress Cloud\nClick Create Bot.\nClick on the newly created Bot\nClick on the Open in Studio button at the top right to open the Cloud Studio interface and start editing your chatbot.\nGet creative!\n\nIn Botpress, each chatbot belongs to a workspace. When you connect to Botpress Cloud for the first time, you'll have a default workspace created automatically for you. You can invite collaborators to contribute to your chatbot by adding them to your workspace.","test-your-chatbot#Test your Chatbot":"There is a chat emulator built in the studio with which you can test your chatbot. You can open it by pressing ctrl + E or cmd + E while in the studio. Note that this shortcut will hide the entirety of the right panel where the emulator is located.The chat emulator represents what your visitors will experience when they speak with your chatbot. You can reset the conversation by clicking the three dots at the top and selecting New conversation or start as a new user. New conversation will only remove temporary variables and start a new conversation while start as a new user will remove any variable saved with the user, starting the entire conversation from scratch.You can get additional information from the bottom panel to understand why you get a specific answer. Note that it is only available for authenticated users. It includes all sorts of useful information: the dialogue engine's elected suggestion, nodes flowed through, and natural language intents or questions. You can also view the raw JSON Payload that contains all details if you need further data. Additionally, you have logs recording all events in the Logs tab of the bottom panel.","publishing-your-bot#Publishing your bot":"Once you're done editing your chatbot, simply click on the Publish button in the top right corner of the studio to deploy your chatbot to your cloud dashboard."}},"/cloud/getting-started/features":{"title":"Botpress Features","data":{"":"","overall-product-specifications#Overall Product Specifications":"Feature\tDescription\tSDK\tThe utility functions that can be used as arguments in user custom code. You can find the NPM here, and API documentation here\tSecurity\tAudit logs for all activities in your workspaceEncryption at rest and in transitRate limits & various HTTP-server limitsSSO - talk to our sales representatives\tCI/CD\tOne-click publish to production\tMulti-Channel Support\tInstantly deliver your bots on all the major messaging channels Botpress WebchatFacebook MessengerMicrosoft TeamsSMS via TwilioWhatsAppLineViberInstagramComing Soon: Intercom, Webhook, Gmail, Rocketchat and more.\tBotpress Webchat\tCreate custom message widgetsCreate your own GUI messages using ReactCustomizable with CSSFlexibility for usersMultiple simultaneous conversations with the same botReset & delete conversation (for privacy purposes)File-sharing using Shareable linkHosted on AWS S3 or BPFS\tCustom Chatbot Branding\tRebrand the Botpress webchat interface\tCommunity Support\tBotpress forum & communityIntercom live support\tMultilingual Support\tSupported Languages: you can use Botpress to make bots in 100+ languages. However during the early preview of the new Botpress, only English is supported for natural language understanding.Learn more about languages: here\tConversational AI Management\tManaged Natural Language Understanding (NLU) Engine - an industrial-grade native NLU engine, from domain specific natural language to structured dataIntent classification - understand the type of action or out of scope conveyed in the sentences and all its participating parts (e.g. book a flight, order dinner, buy a product, etc.)Entity extraction - locate and classify named entities into predefined categories such as person names, organizations, locations, product SKUs, etc. Regex/pattern entities, List entities, Fuzzy matching, pre-built entitiesSlot tagging - tag the words which carry meaning to the sentences (e.g. landing city, type of meal, etc.)Language identification - determining the natural language that a document or part thereof is written in (e.g. English, French, etc.)Natural Language Understanding: any number of languages within the same chatbot; the bot is able to detect the user's language and then answer in kindSpell checking - check for misspellings and automatically fix the spelling mistakes so that the downstream NLU performs more accurately\tBuilt-in Content Types\tSupported content types for each channel\tVisual conversation / dialog management\tVisual developer interface to create and management dialog states and topic Low-code drag and drop user interfaceMultiple visual flows and subflows with conditions divided by topicsMulti-turn and the ability to jump from a topic to another seamlesslyTopic management - process that enables data elements pertaining to a specific topic to be maintained within conversations (e.g. user name, SKU number, etc.)Conversational detours - while the visual flows represent the \"happy paths\" that are desired by the conversation designers, detours are about automatically and gracefully handling exceptionsTemplate management - use pre-made templates to get started or find inspirationIntelligent slot filling - prompting for missing form fieldsWorkflow management - group and reuse flows and subflows to embed and manage domain specific knowledgeCode autocompletion and user interface shortcuts\tFAQ/Q&A\tCreate, manage, and centrally access the most frequently asked questions the users may have Context managementRich messagesMessage \"alternatives\" - the bot doesn’t always say the same thing\tHuman in the Loop (HITL)\tStraightforward integrations with leading third party HITL, including Salesforce, Zendesk, Servicenow, Oracle, Intercom, Genesis, Twilio Flex, Nuance and LiveAgent.\tAnalytics & continuous chatbot training\tDashboards and tools to capture and improve user engagement and chatbot accuracy Misunderstood - capture everything the chatbot doesn't understand and use it to improve your chatbot or expand its capabilitiesEngagementConversationsInteractions\tTesting, debugging, and logging\tEnd-to-end conversation emulation & testing NLU testing Debugging tools Logging\tChatbot privacy\tSensitive data / conversation obfuscationVariable time-based deletionSelective data persistence\tJavascript IDE\tEasily integrate with your internal systems and any third partiesActions & Hooks - create and edit actions within Botpress (e.g. call an API). Features typing and intelligent code completionVS Code embedded in Botpress Studio\tTerms and Conditions\tTerms and Conditions","enterprise-specific-features#Enterprise-Specific Features​":"Feature\n\nDescription\n\n\n\nEnhanced Enterprise Security for Chatbot users\n\nIdentity transmission - securely transmit the user identity to the webchat\nfrom the host web page\n\n\n\nRole-based access control (RBAC)\n\nRBAC - Users can be assigned roles, and permissions can be managed with\nregards to these roles in terms of giving users read and/or write access\nto specific features\n\n\n\nSingle-Sign On (SSO)\n\nSeamlessly link Botpress to your identity provider, OAuth2 for Google,\nGithub, Azure\n\nTalk to sales for more information\n\n\n\nScalability\n\nBotpress has you covered: your chatbot solution adapts instantaneously as\nyour user base grows\n\n\n\nMonitoring\n\nDirectly monitor messages left on your community plan\n\nSet up alerts for messages and keep an eye on your monthly message traffic\n\n\n\nEnterprise Support\n\nAdvanced Botpress technical support\n\nStandard: EST business hours\n\nPremium: 24/7\n\nSLA\n\n\n\nIntegrations\n\nFor a full list of integrations check out our integration\nhub\n\n\n\nCollaboration\n\nReal-time collaboration, with workspaces to organize both chatbots and\ndeveloper work\n\nRealtime collaborative interface (with lock management)\n\nWorkspaces - logical unit that groups up your conversational assistants\nbased on the purpose of the chatbots or for something more granular such\nas for a specific task, etc."}},"/cloud/getting-started/languages":{"title":"Languages","data":{"":"","supported-languages#Supported Languages":"With Botpress, you can build chatbots that are able to converse with people in more than 100+ languages!\nAfrikaans\tAlbanian\tAlemannic\tAmharic\tArabic\tAragonese\tArmenian\tAssamese\tAsturian\tAzerbaijani\tBashkir\tBasque\tBavarian\tBelarusian\tBengali\tBihari\tBishnupriya Manipuri\tBosnian\tBreton\tBulgarian\tBurmese\tCatalan\tCebuano\tCentral Bicolano\tChechen\tChinese\tChuvash\tCorsican\tCroatian\tCzech\tDanish\tDivehi\tDutch\tEastern Punjabi\tEgyptian Arabic\tEmilian-Romagnol\tErzya\tEsperanto\tEstonian\tFiji Hindi\tFinnish\tFrench\tGalician\tGeorgian\tGerman\tGoan Konkani\tGreek\tGujarati\tHaitian\tHebrew\tHill Mari\tHindi\tHungarian\tIcelandic\tIdo\tIlokano\tIndonesian\tInterlingua\tIrish\tItalian\tJapanese\tJavanese\tKannada\tKapampangan\tKazakh\tKhmer\tKirghiz\tKorean\tKurdish (Kurmanji)\tKurdish (Sorani)\tLatin\tLatvian\tLimburgish\tLithuanian\tLombard\tLow Saxon\tLuxembourgish\tMacedonian\tMaithili\tMalagasy\tMalay\tMalayalam\tMaltese\tManx\tMarathi\tMazandarani\tMeadow Mari\tMinangkabau\tMingrelian\tMongolian\tMangolian\tNahautl\tNeapolitan\tNepali\tNewar\tNorth Frisian\tNorthern Sotho\tNorwegian (Bokmål)\tNorwegian (Nynorsk)\tOccitan\tOriya\tOssetian\tPalatinate German\tPashto\tPersian\tPiedmontese\tPolish\tPortuguese\tQuechua\tRomanian\tRomansh\tRussian\tSakha\tSanskrit\tSardinian\tScots\tScottish Gaelic\tSerbian\tSerbo-Croatian\tSicilian\tSindhi\tSinhalese\tSlovak\tSlovenian\tSomali\tSouthern Azerbaijani\tSpanish\tSundanese\tSwahili\tSwedish\tTagalog\tTajik\tTamil\tTatar\tTelugu\tThai\tTibetan\tTurkish\tTurkmen\tUkrainian\tUpper Sorbian\tUrdu\tUyghur\tUzbek\tVenetian\tVietnamese\tVolapük\tWalloon\tWaray\tWelsh\tWest Flemish\tWest Frisian\tWestern Punjabi\tYiddish\tYoruba\tZazaki\tZeelandic","translating-your-chatbot#Translating your Chatbot":"To automatically translate your chatbot to a different language than it was written\nin,\nOn the Left Panel in your Botpress Studio, Click the ⚙️ icon to open up Chatbot Settings.\nEnable Personality Rewrite and select the bot's language from the dropdown. This will instruct the bot to respond in the language of your choice.\n\n\nNote\nIt's currently not possible to build a chatbot that can speak multiple\nlanguages at the same time, i.e. switching between Spanish, English & French\nwithin the same flow."}},"/cloud/getting-started/share-your-chatbot":{"title":"Share your Chatbot","data":{"":"In Botpress Studio, sharing your published chatbot is made easy through the use of a URL generated specifically for your bot. This URL can be shared with others, allowing them to access and interact with your chatbot for testing purposes or general use.","ways-to-share-your-chatbot#Ways to share your Chatbot":"","share-button-in-studio#Share Button in Studio":"The share button, located in the top-right corner of the Studio interface, provides access to this feature.","shareable-url-from-admin-dashboard#Shareable URL from Admin Dashboard":"Go to Botpress Admin Dashboard -> Select your Chatbot -> Channels -> Webchat -> Preconfigured -> Shareable URLHowever, it's important to note that the share button is only enabled once you have published your chatbot using the publish button.This URL can then be distributed to individuals or teams who need to test or utilize your chatbot. By sharing the URL, others can easily access and interact with your chatbot through a web browser, eliminating the need for them to install any additional software."}},"/cloud/getting-started/tips-and-tricks":{"title":"Tips & Tricks","data":{"":"","send-an-api-request#Send an API Request":"These are guides on using the Execute Code Card in Botpress to access APIs to read and update data. Following the guide, you'll be able to send emails (using the SendGrid API), and read data from an api (the Bored API, which gives interesting todo suggestions).\n\nThe API calls will be performed using the Botpress built-in axios client, and the\ncode will run in the Execute Code Card.","the-axios-library#The Axios Library":"Botpress comes with a built-in reference to the axios NPM library which allows you to easily do calls to APIs. Whenever you want to call an API, you can just reference axios in the code editor. There is no need to require or import it!\nFor more information about how to use axiosNPM: https://www.npmjs.com/package/axios","the-sendgrid-service#The SendGrid Service":"We will be using SendGrid as an example of how to send emails. You can choose any other provider, like Gmail, Microsoft, etc. But you will need to change the code based on the provider you want to integrate with.\nFor more information about SendGrid: https://sendgrid.com/","the-bored-api#The Bored API":"The Bored API's motto is : Let's find you something to do! We will be using Bored API as an example of how to call APIs to fetch information.\nFor more information about Bored API: https://www.boredapi.com/","getting-started---update-information#Getting Started - Update Information":"First, we need to create an account: Create a SendGrid account. You can choose Free for trial purposes.\nAs soon as you land in your newly created account, on the left-hand side menu, there is a menu item named Email API expand it and click on Integration Guide.\nNext, you will be prompted to Create an Identity.\nEnter the needed details and click Create, then you will receive a verification email. Open it and click Verify.\nNow, your sender is created and ready to be used. Let's create the API key we will be using when doing our API calls: Create an API Key.\nOn the top right of the screen, click on Create API Key. Create a name for your key - this is irrelevant to Botpress; it is more for your sake to know what this API key is used for.\nAfter the key is created, copy the key value - keep it safe - we are going to use it soon.\nThen we go to Botpress, open our bot, and add an Execute Code card. Then in the card, make sure to disable the generative AI by clicking on the button.\nThen paste the below code in it after changing the variables [sendgrid_api_key], [from_email], and [to_email].\n\n\nsendgrid_api_key is the API key generated in the Send Grid API Key.\nfrom_email is the email configured as a sender.\nto_email is the email we are sending to.\n\n\n\n\n\nAfter successfully integrating the SendGrid API into Botpress, it's time to test it.For more information: https://docs.sendgrid.com/for-developers/sending-email/api-getting-started","getting-started---get-information#Getting Started - Get Information":"Go to Botpress, open our bot, and add an Execute Code card. Then in the card, make sure to disable the generative AI by clicking on the [button image] button.Then paste the below code in it. The code calls Bored Panda API to retrieve information about random activities:\n\nThe response will look something like that:\n\nTo access the information in the response, use response.data.type. You can also pass this information back into your workflow by adding the retrieved information into a workflow variable: workflow.participantType = response.data.type.","conclusion#Conclusion":"Integrating with a system or platform that has APIs may require some technical experience, but it is easy to acquire. Following the steps outlined in this guide, you can easily call APIs and retrieve information to enhance your application.","use-chatgpt-api-in-execute-code#Use ChatGPT API in Execute Code":"If you are using Botpress and want to integrate the ChatGPT API to generate AI-powered responses for your chatbot, follow these simple steps:Step 1: Create a variable in your Botpress workflow to store the ChatGPT API's response.Step 2: Add the Execute Code card to your Botpress flow and paste the code below:\n\nMake sure to replace <OpenAI's APIKey> with your actual OpenAI API key, and variableName with the name of the variable you created in Step 1.Step 3: Test your chatbot in the Botpress Emulator to see if it's generating AI-powered responses.\nNote\nIt's important to note that using this method, ChatGPT does not preserve the\ncontext of the messages that you've sent. However, it's a great way to get\nstarted with integrating AI-powered responses into your chatbot without\nneeding any technical knowledge."}},"/cloud/studio/chatbot-settings":{"title":"Chatbot Settings","data":{"":"On the Left Panel in your Botpress Studio, Click the ⚙️ icon to open up Chatbot Settings.","general-settings#General Settings":"","chatbot-name#Chatbot Name":"The Chatbot Name refers to the name of your chatbot that will be displayed as the identity or persona of the bot on various channels. It represents the character or entity that users interact with when communicating with the chatbot.For example, if you have a chatbot designed to assist customers with travel bookings, you may choose an Avatar Name like Travel Buddy, WanderlustBot, or TravelGuideX. These names convey the bot's role and create an engaging and friendly persona for users to interact with.On the other hand, if your chatbot is focused on providing technical support for software products, you might opt for a more professional-sounding Avatar Name like TechAssist, SupportBot, or TechGenius.","language#Language":"With Botpress, you can build chatbots that are able to converse with people in 50+ pre-loaded languages.To customize your chatbot's language, follow these steps:\nOpen the dropdown menu and select your preferred language.\nEnsure that the personality rewrite option is enabled to apply the changes.\nOnce the changes are applied, your chatbot will use the selected language for its interactions.","personality-rewrite#Personality Rewrite":"When the feature of personality rewriting is enabled, it means that the messages sent by the bot will be modified or rewritten to match the specific personality of the bot. This can be done by programming the bot to use specific language patterns, tone, and expressions that reflect the personality traits of the bot.For example, if the bot has been designed to have a friendly and casual personality, its messages may use more informal language and include emojis or other forms of digital communication commonly associated with a friendly tone. Alternatively, if the bot is designed to be more professional and formal, its messages may use more formal language and adopt a more serious tone.The purpose of personality rewriting is to make the bot's communication more engaging and natural for users. By matching the bot's personality to the message being sent, it can create a more personalized and relatable experience for the user, increasing the likelihood that they will engage with the bot further.Know more about Best Practices for writing your chatbot's personality.Understand about Chatbot Personality in detail here -> Chatbot Personality","variables#Variables":"","user-variables#User Variables":"User Variables are associated with individual users and are persistent. These variables can be set and accessed during the conversation with the chatbot. Examples of user variables may include user preferences or settings.","bot-variables#Bot Variables":"Bot Variables, on the other hand, are the same for all users of the bot and can be used to store information that is relevant to the chatbot's functionality or behavior.","configuration-variables#Configuration Variables":"Configuration Variables are containers that store essential information such as API keys and database credentials, and allow chatbot developers to easily access and modify them as needed."}},"/cloud":{"title":"Botpress Cloud Documentation","data":{"":"Start with creating a basic bot and publishing it to the dashboard.\n\nDiscover the diverse range of features available in Botpress.\n\nKnow more about configuring your chatbot in the Admin Dashboard.\n\nConnect your chatbot to your knowledge by uploading your documents & websites.\n\nUtilize the power of Generative AI to optimize your workflows and enhance productivity.\n\nDiscover the various components of the Botpress Studio Interface and how to use them effectively.\n\nIntegrate your Botpress chatbot with various messaging channels.\n\nCustomize the appearance of your chatbot using the Botpress Studio Interface.\n\nUse Keyboard Shortcuts in Botpress Studio for increased efficiency."}},"/cloud/studio/agents":{"title":"Agents","data":{"":"Botpress offers a variety of specialized Agents to enhance your chatbot's capabilities and adaptability. These Agents are designed to perform specific tasks, each contributing to the overall performance of your chatbot. Here, we introduce four of our agents: Summary, Personality, Knowledge, and Translator Agents.","summary-agent#Summary Agent":"The Summary Agent is designed to condense lengthy user responses or extensive text into a brief, digestible summary. This feature is crucial in ensuring that the main ideas are quickly understood, thus making interactions with your bot more efficient.","input-parameters#Input Parameters":"Summary Max Tokens: This defines the maximum length of the generated summary in tokens. A token can be a word or a punctuation mark. This parameter allows you to set a limit on how lengthy your summaries can be, ensuring they remain concise and manageable.","output-parameters#Output Parameters":"conversation.SummaryAgent.summary: This is the generated summary of the conversation thus far. It's important to note that this parameter is only available after each conversation turn.","usage#Usage":"Upon enabling the Summary Agent, the conversation summary becomes accessible through the {{conversation.SummaryAgent.summary}} variable. This variable can be incorporated in any place where user code is permitted. This includes Hooks, workflow Executed Code cards, AI Task cards, and Transition cards.For example, if you wish to include a conversation summary in a chatbot prompt, you could write:\n\nThis would then output a brief summary of the conversation so far.","conflicts#Conflicts":"There are no known conflicts with the Summary Agent and other Botpress functionalities or agents. However, please remember that the output from the Summary Agent (conversation.SummaryAgent.summary) is updated after each conversation turn. Therefore, ensure that you use it in context and check the summary only when it is updated.","translator-agent#Translator Agent":"The Translator Agent allows your chatbot to interact with users in different languages, breaking language barriers and expanding the range of your bot's audience. This agent translates the incoming user messages to a language that your chatbot can understand and processes its responses back to the user's language.","input-parameter#Input Parameter":"Detect User Language: When enabled, this option allows the Translator Agent to identify the user's language based on their input automatically. If the user's language has yet to be discovered, it can be determined if the input message is long enough to discern it. Activating this feature consequently sets the {{user.TranslatorAgent.language}} variable when it's not already defined.","output-parameter#Output Parameter":"user.TranslatorAgent.language: This variable represents the detected language of the user. By setting this variable to null, the language detection can be reset. Alternatively, to specify a language, you can set it to any valid ISO 639-1 language code (e.g., 'en', 'fr', 'es').","usage-1#Usage":"The Translator Agent automatically translates the chatbot's responses into the user's language once activated. If you wish to define the user's language manually, you can directly set the {{user.TranslatorAgent.language}} variable. This can be set to any ISO 639-1 language code, such as 'en' for English, 'fr' for French, or 'es' for Spanish.For instance, if you'd like to set the user's language to Spanish, you can use:\n\nIf you want to reset the language detection and allow the Translator Agent to determine the user's language from their input automatically, set the variable to 'null' or 'undefined'. For example:","conflicts-1#Conflicts":"It is important to note that the Translator Agent may conflict with the Personality Agent. The Personality Agent is designed to manipulate chatbot responses according to pre-set personalities and could overwrite the translations done by the Translator Agent. If both the Translator Agent and the Personality Agent are enabled, the Personality Agent will take priority. If you want the Translator Agent to take effect, you may need to adjust the settings of the Personality Agent or turn it off.","personality-agent#Personality Agent":"The Personality Agent enables you to provide your chatbot with a unique personality. It tailors the bot's behavior and responses according to the defined personality traits, providing a more engaging and human-like interaction for the users.","personality-description#Personality Description":"This is where you define the personality of your chatbot. You should describe how your chatbot is meant to behave and what it is meant to do. Including specific personality traits will influence the bot's responses. For example, if you describe the bot as a \"funny cowboy that likes to add emojis to some of your messages and often refers to the user as 'my friend'\", the bot will mimic this behavior in its responses.The Personality Agent, once enabled, will automatically rewrite all the messages sent by your bot to align with the described personality. For instance, if your bot is described as having a humorous and friendly personality, its responses may contain light-hearted quips or friendly salutations such as \"Hello, my friend!\"This may add some latency to your bot's responses as it takes time to process and rewrite the messages according to the defined personality traits.For instance, if you want your bot to behave like a professional consultant, you might write:","conflicts-2#Conflicts":"Be aware that the Personality Agent can conflict with the Translator Agent. If both are enabled, the Personality Agent has higher priority and may overwrite the translations done by the Translator Agent. Thus, if you want to ensure the effectiveness of translations, you should adjust the settings of the Personality Agent or turn it off.","knowledge-agent#Knowledge Agent":"This agent will make your chatbot answer questions from Knowledge Bases.It will look for questions in the user's message and try to find an answer in the context Knowledge Bases.The Knowledge Bases that are searched are the ones that are in the same folder as the current workflow, or in the parent folders.The agent will only answer when the user asks a question and the chatbot is either on the Start Node or when the workflow is on a Capture Card inside a node that has Knowledge Bases enabled.To enable Knowledge Bases on a node, click on the node in the workflow editor and then enable the Knowledge Bases option in the right inspector panel."}},"/cloud/studio/emulator":{"title":"Emulator","data":{"":"You can debug your bot conversation using the built-in Emulator in the right-side panel.\nNote\nTo visualize the entire user experience, you should use the Web Channel directly. All the messages you send with the\nEmulator come from the same user from the bot's perspective.","status-indicator#Status Indicator":"🟠 Training\nThis indicates that the bot is getting trained using your latest edits in the studio.🟢 Ready\nThis indicates that the bot has been trained and is ready for testing in the emulator.🔴 Error\nThis indicates that the bot could not be trained and has some errors.","opening--closing-the-emulator#Opening & Closing the Emulator":"Press cmd/ctrl + e to toggle the Emulator (Right Panel)","resend-the-same-messages#Resend the Same Messages":"Pressing ↑ or ↓ on your keyboard in the text input allows you to navigate and resend previously sent messages quickly.\nThe last 20 messages sent to this bot are persisted in your browser storage.","new-conversation#New Conversation":"Go to the 3 dots at the top right corner of the emulator and click on New Conversation. This will erase the history and state from the old conversation and start a new conversation with the same user information.","start-as-a-new-user#Start as a new user":"Go to the 3 dots at the top right corner of the emulator and click on Start as new user. This will erase the history and state from the old conversation and start a new conversation with different user information."}},"/cloud/studio/botpress-hub":{"title":"Coming soon!","data":{"":"Meet our unparalleled set of pre-built integrations and skills."}},"/cloud/studio/event-debugger-logs-json":{"title":"Debugger, Logs & JSON","data":{"":"","event-debugger#Event Debugger":"The Event Debugger provides information on how your bot understood the user's message and why it made specific decisions. It also displays the complete event payload, including NLU metadata, state, and raw responses.\n\nTo open or close the Debugger, you can use the keyboard shortcut cmd/ctrl + j.\nThis will toggle the Debugger on and off and allow you to access the information\nit provides.","logs#Logs":"By using logs, you can see what happened step-by-step before an error occurred. This can help you understand what went wrong and how to fix it.\n\nIt's important to include enough logging in your bot to ensure that you have enough\ninformation to find and fix issues. By analyzing the Botpress Logs, you can pinpoint\nexactly where the problem occurred and take the necessary steps to resolve it.","state#State":"In a bot conversation, each session has an associated state which is created at the beginning of the conversation just before the Entry Node is processed. The state persists throughout the conversation and is used to keep track of information related to the ongoing interaction with the user.The state is global to the conversation, which means that if the conversation spans multiple flows, all the flows will share the same state. This allows information to be passed between flows and ensures that the bot has a consistent view of the conversation history.The state can be used to store variables, such as the user's name, preferences, or history of interactions, that are needed throughout the conversation. It can also be used to keep track of the bot's progress through the conversation, such as which questions have been asked and which tasks have been completed.By using the state effectively, you can create more personalized and engaging bot experiences for your users.","json#JSON":"This tab displays the raw information that is processed during each conversation exchange in the Botpress Emulator. The information can be accessed through event.property, where \"property\" refers to one of the properties listed in the table below.\n\nHere is a table that describes each property in detail:\nProperty\tDescription\tType\tA string property that indicates the type of the message, e.g., text, audio, video, etc.\tChannel\tA string property that specifies the channel or platform through which the message was received. For example, the channel can be an emulator, Facebook Messenger, WhatsApp, etc.\tDirection\tA string property that specifies the direction of the message, i.e., whether the message is incoming or outgoing.\tPayload\tA JSON object that encapsulates the message data. The structure of the payload object depends on the type of message.\tUserId\tA string property that identifies the user who sent the message.\tBotId\tA string property that identifies the bot or conversational AI system that received the message.\tCreatedOn\tA timestamp that specifies the date and time when the message was received.\tConversationId\tA string property that identifies the conversation thread to which the message belongs.\tId\tA unique identifier for the message.\tPreview\tA preview or summary of the message.\tMessageId\tA string property that identifies the ID of the message.\tTags\tAn object that contains tags associated with the message.\tFlags\tAn object that contains flags associated with the message.\tState\tAn object that contains the state of the conversation.\tSuggestions\tAn array of suggested responses or actions that the bot can take based on the message.\tNLU\tAn object that encapsulates the results of the natural language understanding (NLU) process for the message.\tDecision\tAn object that encapsulates the decision-making process for the message."}},"/cloud/studio/explorer":{"title":"Explorer","data":{"":"The Explorer panel is located on the left-hand side of the Studio Interface, and it contains your chatbot's Workflows and Knowledge Bases.","folders#Folders":"Click on the Add Folder Icon from the top of the Explorer Menu.Folders can be a helpful organizational tool when working with workflows in a chatbot development platform. By creating folders, you can group related workflows together and effectively manage and navigate through your workflow collection.Here are some ways folders can help workflows:Organization and Structure: Folders provide a logical structure to categorize and organize your workflows based on their purpose, functionality, or any other relevant criteria. This helps in maintaining a well-structured and easily understandable workflow hierarchy.Ease of Navigation: As your collection of workflows grows, it can become challenging to locate specific workflows quickly. Folders allow you to group workflows into different categories, making it easier to find and access the desired workflow when you need it.Simplified Workflow Management: With folders, you can perform actions on multiple workflows simultaneously. For example, you can move, copy, or delete entire folders, which in turn affects all the workflows contained within them. This saves time and effort when managing a large number of workflows.","workflows#Workflows":"Click on the Add Workflow Icon from the top of the Explorer Menu.Workflows allow you to break down a complex chatbot into multiple smaller flows. Breaking down the chatbot into multiple flows makes it easier to maintain and reusable.","knowledge-base#Knowledge Base":"Click on the Add Knowledge Base Icon from the top of the Explorer Menu.The Knowledge Base allows you to manage and access all your organizational knowledge in one place. You can upload various types of knowledge sources, including PDFs, static text, and website URLs."}},"/cloud/studio/hooks":{"title":"Hooks","data":{"":"The Hooks Tab of the Explorer panel allows you to create Hooks. Hooks are event-driven custom code snippets.Hooks are a handy way to execute JavaScript code when specific events occur. (similar to Execute Code cards and Validation fields)\nNote\nEditing a hook takes immediate effect, which means it will execute with the changes on the next event. This makes\ndevelopment a lot faster.\nHooks are differentiated using the point in the event engine when they are executed. The following are instances where you can inject hooks into your code.","after-incoming-message#After Incoming Message":"This hook is called right after all incoming middlewares have processed the event but before the Dialogue Engine starts processing it. You can access all the required data (including NLU intent) for special processing and decide what happens to the event.\nParameters: bp, event\nA typical operation here is to tell Botpress to ignore the event and not process it (e.g., not send it to the dialogue engine).","before-incoming-message#Before Incoming Message":"Botpress calls this hook after receiving an event but before processing any middleware. It is possible to change event properties.\nParameters: bp, event\nBotpress often uses this hook to set flags to skip some processing, for example, to prevent the QnA from processing it when it's a quick reply.","before-outgoing-middleware#Before Outgoing Middleware":"The Dialogue Manager calls this hook before the bot's reply is sent to the user.\nParameters: bp, event\nHere you can save the bot's complete response."}},"/cloud/studio/inspector":{"title":"Inspector","data":{"":"The top right-hand side panel is the Inspector. The Inspector will display additional properties of the components you select in the main (center) panel.","logged-in-account#Logged-in Account":"Shows the Account that you've logged in. Click on it to log-out.","search#Search":"A powerful search bar allows you to find anything within your bot with a simple keyword.\nShortcut: ctrl+f / cmd + f","share#Share":"A powerful search bar allows you to find anything within your bot with a simple keyword.\nShortcut: ctrl+f / cmd + f","publish#Publish":"Your chatbot will only be made publicly available (or updated) when you publish it with this one-click deployment to the cloud."}},"/cloud/studio/knowledge-base":{"title":"Knowledge Base","data":{"":"The Botpress Knowledge Base is a powerful tool that allows users to manage and access organizational knowledge in one central location.It has been designed to replace the traditional Q&A system and enable users to upload various sources of information, including PDFs, plain text, and website URLs.It's worth noting that the Plain Text Knowledge Base replaces our old Q&A system, while the Web Search Knowledge Base replaces Botpress GO.","creating-a-knowledge-base#Creating a Knowledge Base":"To create a Knowledge Base, click on the + Knowledge Base Icon in the Explorer on the left panel of the studio. You can create folders and organize your knowledge bases as per your preferences.","description#Description":"When you create a Knowledge Base in Botpress, it's important to provide a brief description that explains what the Knowledge Base is about and what kind of information it contains.This helps the system understand what type of questions to expect and gives it a better chance of finding the right answers for your users.","how-to-write-the-description#How to write the description":"Let's say you work at a company that sells different types of home appliances, such as refrigerators, washing machines, and ovens. You can create a Knowledge Base in Botpress to help your customer support team quickly find information and answers to common questions about these products.When creating the Knowledge Base, you would provide a brief description that outlines the purpose and scope of the Knowledge Base.For example,\n\"This Knowledge Base provides information and support for our home appliances product line, including troubleshooting tips, user manuals, and frequently asked questions.\"This description helps the NLU engine understand the focus of the Knowledge Base and identify the relevant sources of information to answer customer queries, such as \"How do I clean the filter in my washing machine?\" or \"What should I do if my oven is not heating up properly?\"","knowledge-sources#Knowledge Sources":"","1-plain-text#1. Plain Text":"The Plain Text KB Source allows users to create/add plain textual information, such as FAQs, guides, and manuals. This Knowledge Base replaces Botpress's old Q&A system and is designed to provide users with quick access to information on various topics.Here's an example of how the Plain Text Knowledge Base could be used in a company that sells different types of home appliances, such as refrigerators, washing machines, and ovens:Let's say that the customer support team at this company receives a lot of questions about how to troubleshoot common problems with their products. The team decides to create a Knowledge Base in Botpress to provide quick and easy access to this information.Using the Plain Text Knowledge Base, the team creates a series of plain text documents that contain troubleshooting tips for each type of product. They organize these documents by title (e.g., \"Refrigerators,\" \"Washing Machines,\" \"Ovens\") and add description for common issues (e.g., \"Not cooling,\" \"Won't spin,\" \"Not heating up\").So, when users search for a specific problem like My refrigerator is not cooling, Botpress's Natural Language Understanding (NLU) functionality will retrieve the relevant response from the plain text Knowledge Base, providing users with the necessary troubleshooting information.","2-documents#2. Documents":"The Documents KB Source allows users to upload various file formats, including PDFs, HTML files, TXT files, DOC files, and DOCX files. This feature enables users to create a comprehensive Knowledge Base by incorporating different types of documents, such as manuals, guides, reports, and more.Let's consider a scenario where a company deals with medical equipment. The organization's support team frequently encounters inquiries about the usage and maintenance of their products. To address this, they decide to utilize the Documents Knowledge Source in Botpress to provide customers with easy access to relevant information.Using this feature, the team uploads a range of files related to their medical equipment, such as PDF manuals, HTML guides, and TXT documents containing troubleshooting steps. They organize these documents into appropriate categories, such as \"Product Manuals\", \"Troubleshooting Guides\", and \"Usage Instructions\", ensuring that customers can find the information they need quickly.For instance, if a user searches for \"How to calibrate the XYZ device,\" Botpress will search through the uploaded documents, and return the relevant instructions from the Knowledge Base.","supported-file-formats#Supported File Formats":"PDF documents are commonly used for manuals, guides, and other types of documentation. With Botpress, you can upload PDFs to your Knowledge Base, making it easy for employees to search for and access the information they need.\nHTML documents are used for web pages and other online content. By uploading HTML documents to Botpress, you can make this web content accessible to employees who may not have internet access.\nTXT files are plain text documents, similar to the ones supported by the Plain Text Knowledge Base. However, TXT files can contain more complex formatting, such as tables and images. By uploading TXT files to Botpress, you can make this type of content searchable and easily accessible.\nDOC and DOCX files are commonly used for word processing documents, such as memos and reports. By uploading these files to Botpress, you can make them searchable and easily accessible to employees.","3-web-search#3. Web Search":"When using the Web Search Knowledge Base Source, you have the ability to specify the websites to include or exclude from your search. This allows you to customize the search to meet your specific requirements. Here are three options you can consider:","on-which-websites-should-we-search-on#On which websites should we search on?":"Search on specific websites: You can provide a list of website domains that you want the Botpress NLU engine to include in its search. For example, if you want to focus on retrieving information from trusted sources within your organization, you can include domains like \"yourcompany.com\" or \"internalknowledgebase.com\". This ensures that the search is targeted to specific websites relevant to your Knowledge Base.\nSearch the entire web: If you select this option, the Botpress NLU engine will conduct searches across the entire web. This is useful when you want to gather information from a wide range of sources, including external websites and online communities. It enables you to access a broader set of information that may be helpful to your Knowledge Base.\nExclude specific websites from the search: Sometimes, you may want to exclude certain websites from the search results. This option allows you to specify a list of website domains that should be excluded from the search. For example, if you want to filter out unreliable sources or competitor websites, you can exclude their domains from the search. This ensures that the search focuses on credible and relevant information.","filter-search-results-by-time-period#Filter search results by time period":"When utilizing the Web Search Knowledge Base Source, you can further enhance your search capabilities by filtering search results based on a specific time period. This feature allows you to narrow down the results to obtain the most relevant and up-to-date information for your Knowledge Base.To enhance your web search capabilities and filter search results by time period, you can utilize the following options:\nDo not filter based on time: Selecting this option ensures that the search results are not filtered based on a specific time period. It includes all available information without any time restrictions.\nPages discovered in the last 24 hours: By choosing this option, the search results will focus on web pages that have been discovered or indexed within the past 24 hours. This allows you to access the most recent information available on the web.\nPages discovered in the last 7 days: Selecting this option narrows down the search results to web pages that have been discovered or indexed within the past 7 days. It helps you stay updated with recent developments and information.\nPages discovered in the last 30 days: This option filters the search results to include web pages that have been discovered or indexed within the past 30 days. It provides a slightly broader time range for retrieving recent information.\n\nBy utilizing these options, you can tailor the time period for your web search and ensure that the search results align with your Knowledge Base requirements. Whether you prefer real-time updates or a broader range of recent information, these options help you refine your search results accordingly.","enablingdisabling-kb-on-nodes#Enabling/Disabling KB on Nodes":"In Botpress, you have the ability to enable or disable the Knowledge Base feature for specific nodes that utilize the Capture Info action.To enable the Knowledge Base on nodes with a Capture Information Card:\nLocate the nodes that include a Capture Information Card.\nIn the Inspector panel, look for the option called Enable Knowledge Answering and select it.\n\nBy enabling this option, you allow the Knowledge Base to provide answers during the interaction when the user is asked for a response. If the user's input is relevant to the information stored in the Knowledge Base, Botpress's Natural Language Understanding (NLU) will retrieve the corresponding answer from the Knowledge Base and display it to the user. The conversation then proceeds to the next step of capturing information.\nThis feature helps to enhance the user experience by providing quick and accurate answers sourced from the Knowledge Base when appropriate.If you disable the Knowledge Base feature on nodes that use the Capture Info action in Botpress, the system will not utilize the Knowledge Base to provide answers during the interaction.Disabling the Knowledge Base means that when users are prompted for a response and their input matches a query that could be answered using the Knowledge Base, Botpress's NLU will not retrieve answers from the Knowledge Base. Instead, the conversation will continue without incorporating information from the Knowledge Base.By disabling the Knowledge Base, you essentially exclude it as a potential source of information for those specific nodes. This may be useful if you want to handle user responses differently or if you prefer to rely on other mechanisms to provide answers or capture information in those particular nodes.","example#Example":"Let's consider an example of a chatbot for a travel agency. The bot is designed to capture information from users regarding their travel preferences and provide relevant recommendations. The bot uses the Capture Info action in certain nodes to gather specific details from users.\n\nThe conversation then proceeds to the next step of capturing additional information, such as travel dates or budget.\n\nThe conversation continues to the next step based on the specific logic or action defined for that node, without utilizing the Knowledge Base to provide answers or additional information.In both examples, enabling or disabling the Knowledge Base on nodes using the Capture Info action determines whether the bot incorporates Knowledge Base information into the conversation flow or relies solely on other mechanisms to handle user responses."}},"/cloud/studio/library":{"title":"Library","data":{"":"Part of the Botpress NLU (Natural Language Understanding)The second tab of the Explorer panel is the Library. Here you will find your global Intents and Entities. In addition to global Intents, Botpress provides Inline Intents that can be defined on a Transition.","intents#Intents":"Recognizing the meaning of user messages is essential. It’s critical not only to identify them, but also accurately classify them. To do so, you can program your chatbot to extract information from a natural conversation (i.e. a conversation with a human).When you create an intent, you also add utterances. Utterances represent the different statements your user can use to say or ask for the same thing.You can also use them as inline intents for transitions.For example, we can add the following utterances to the “Ordering a coffee” intent:\nI want coffee\nI'd like some coffee, please\nDo you have a decaf espresso?\nHi. I'd like to order a latte, please. Normal, single shot.\n\nYou can add these different utterances to train your chatbot to answer an intent instead of a specific word. The user statements are compared and matched with the most appropriate intent with the highest confidence score.\nUser Message\tIntent Matched\tConfidence\tI would like to order a coffee.\tplace-order\t0.97\tAn espresso, please\tplace-order\t0.91\tCan you please give me a double cappuccino?\tplace-order\t0.96","adding-an-intent#Adding an Intent":"To create a new intent,\nIn your Conversation Studio, click the Library tab from the top left corner.\nClick the + button.\nGive it a friendly name.\nClick Submit.\nWrite your utterances next to the number (where you can see type a sentence).\n\n\nNote\nUtterances currently have a maximum of 280 characters.","slots#Slots":"Slots are a significant concept in the Botpress NLU. You can think of them as necessary parameters to complete the action associated with an intent.","slot-tagging#Slot Tagging":"The Botpress Native NLU will tag each word of user input. Words separated by a hyphen are treated as one word. If the word is correctly identified as a slot, it will be attached to the NLU extraction event. Each identified slot will be accessible in the event.nlu.slots object using its name as the key.\nDefining Slots\nIn your Conversation Studio, click the Library tab from the top left corner.\nSelect the intent you want to add slots too,\nClick Create a Slot.\nLet's use a book_flight intent. To book a flight, we'll define two slots: departure and destination, both associated with the Airport Codes custom list entity. Once that is done, we need to identify every airport slot.","entities#Entities":"You can think of Entities as intent parameters. They represent a concept such as a colour, a date, a time, or a weight. Entity extraction helps you extract and normalize desired entities if they are present in a user phrase or message to the chatbot.Example: The place-order intent contains the following entities:\ncaffeine that specifies if the coffee is caffeinated or decaffeinated.\nsize for a single or a double shot.\ndrink that specifies the kind of drink asked.\nAttached to NLU extraction, you will find an entities property which is an array of System and Custom entities.","custom-entities#Custom Entities":"Botpress provides two types of custom entities: pattern and list entities. To define a custom entity, go to the Library tab of the Explorer. From there, you can define your custom entities which will be available for any input message treated by your chatbot. Go ahead and click on New entity.","using-entities#Using Entities":"You may access and use entity data by looking up the event.nlu.entities variable in your hooks, flow transitions or Execute Code cards.","system-entities#System Entities":"The Botpress Native NLU offers several system entities for extraction. It can extract these entities:\nAmount of money\nDistance\nDuration\nEmail\nNumber\nOrdinal\nPhone number\nQuantity\nTemperature\nTime\nURL\nVolume\nExample:\nUser said\nType\nValue\nUnit\nAdd 5 lbs of sugar to my cart\nquantity\n5\npound","list-entities#List Entities":"List extraction behaves similarly to pattern extraction. However, you'll be able to add different occurrences of your entity with corresponding synonyms.\nLet's take Airport Codes as an example:\nExtraction will go like this:\nUser said\nType\nValue\n\"Find a flight from SFO to Mumbai\"\n\"Airport Codes\"\n[\"SFO\", \"BOM\"]","pattern-entities#Pattern Entities":"Pattern or Regular Expression Extraction allows you to extract information presented in a format that can be described using Regular Expression (RegEx). Once you've created a pattern entity, Botpress Native NLU will perform a regex extraction on each incoming message and add it to event.nlu.entities.\nExample:\nGiven a Pattern Entity definition with [A-Z]-[0-9]-[A-Z] as a pattern:\nExtraction will go like this:\nUser said\nType\nValue\nFind product BHZ-1234-UYT\nSKU\nBHZ-1234-UYT","sensitive-information#Sensitive Information":"Messages sent between users and the chatbot are stored in the database, which means that sometimes your chatbot may save personal information (e.g., a credit card number). To protect the chatbot user's confidential information, use the small checkbox located in the upper right corner labeled sensitive when creating such entities.\nWhen checked, your chatbot will still display the information in the chat window, but the sensitive information will be replaced by * before being stored. The original value is still available from event.nlu.entities"}},"/cloud/studio/preferences":{"title":"Studio Preferences","data":{"":"","workflow---snap-to-grid#Workflow - Snap to Grid":"The Snap to Grid feature in Botpress allows you to align nodes and connectors on the grid(flow-editor/canvas), making it easier to organize and visualize the flow of your chatbot.To enable Snap to Grid, follow these steps:\nOpen the Botpress Studio and navigate to the Botpress Icon (top-left)\nGo to Preferences -> Check the box -> Workflow - Snap to Grid.\n\nOnce Snap to Grid is enabled, the nodes and connectors will automatically align to the nearest grid lines when they are moved.Note that the Snap to Grid feature is optional and can be disabled at any time by unchecking the Snap to Grid box in the settings menu.","freeform#Freeform":"When the Snap to Grid feature is turned off, the workflow editor allows for more free-form movement of nodes and connections. Nodes and connections can be dragged and placed anywhere on the canvas, without being automatically aligned to the grid.This can be useful for creating more complex and visually dynamic workflows that don't conform to a strict grid layout.However, it can also make it more difficult to align nodes and connections precisely, which may be necessary for ensuring the logical flow of the conversation.","benefits-of-using-snap-to-grid#Benefits of using Snap to Grid":"Increased organization and clarity: Snap to Grid helps to organize the flow of your chatbot by aligning nodes and connectors on a consistent grid.\nTime-saving: Aligning nodes and connectors manually can be time-consuming. Snap to Grid makes this process faster and more efficient.\nImproved visual representation: The visual representation of your chatbot becomes more clear and professional-looking with the use of Snap to Grid."}},"/cloud/studio/nodes":{"title":"Nodes","data":{"":"Nodes are the primary units of conversational logic of your chatbot. A node generally transitions to another node or flow. You can think of a node as a step in a conversation.A single node can have multiple content types, instructions, and transitions. When there aren't any more transitions, the conversation ends.Node types: Start, Entry, Standard, Exit and End","types-of-nodes#Types of Nodes":"","start-node#Start Node":"The Start Node is a specialized Entry Node that is only available in the main flow of a Botpress bot. It serves as the starting point for the conversation and can only execute transitions to other standard nodes.","entry-node#Entry Node":"Every workflow in your bot, except the main flow, starts with an Entry node. The Entry node is the starting point for each individual workflow and can only execute transitions to other standard nodes within that workflow. It is used to define the entry point for the workflow and the initial conditions that must be met for the workflow to start executing.","exit-node#Exit Node":"Similar to the Entry node, every workflow in your bot, except the main flow, should end with an Exit node. The Exit node is the final node in a workflow and can only receive transitions from other standard nodes within that workflow. It is used to define the exit point for the workflow and specify the conditions that must be met for the workflow to end. The Exit node typically contains cleanup or finalization logic, such as sending a message to the user or updating a database, before the workflow is completed.","standard-node#Standard Node":"The Standard node is a versatile building block in your bot's workflow. It allows you to add both instructions and transitions to your flow, and it can be used to represent a variety of steps in the conversation with the user.You can add instructions to the Standard node to define what the bot should do at that point in the conversation, such as sending a message or asking the user for input. You can also add transitions to the Standard node to specify the conditions under which the conversation should proceed to the next node.Standard nodes can be connected to other nodes within the same workflow using transitions, allowing you to create complex conversation flows that adapt to the user's input and actions. They are essential building blocks for creating conversational AI experiences that are engaging and useful for your users.","end-node#End Node":"The End Node is a unique node in your bot's Main Flow. Its purpose is to clear the conversation session and reset the bot to its initial state once it is reached. When the End Node is executed, it will erase all variables and user data associated with the conversation and set the cursor back to the beginning of the Main Flow.The End Node is typically used when you want to reset the conversation with the user and start a new session from scratch. It is particularly useful for bots that handle sensitive or personal information, where it is important to ensure that previous session data is not accessible to subsequent users.Note that the End Node is only available in the Main Flow of your bot and cannot be used in other workflows."}},"/cloud/studio/shortcuts":{"title":"Keyboard Shortcuts","data":{"":"You can use these studio shortcuts for saving your time and focusing on building better chatbots.\nShortcut\tWindows\tMac\tCopy Node\tctrl+c\tcmd+c\tPaste Node\tctrl+v\tcmd+v\tDelete Node\tdel\tdel\tSearch\tctrl+f\tcmd+f\tToggle Left Panel  (Explorer, Library, Hooks)\tctrl+b\tcmd+b\tToggle Right Panel  (Inspector & Emulator)\tctrl+e\tcmd+e\tToggle Bottom Panel  (Debugger & logs)\tctrl+j\tcmd+j\tMessage History  (Emulator, previous messages)\tArrow ↑ or ↓\tArrow ↑ or ↓\tCreate New Session  (Emulator)\tctrl+Enter\tctrl+Enter"}},"/cloud/studio/variables":{"title":"Variables","data":{"":"Botpress variables are variables that you can create within a Botpress chatbot to store information and use it in different parts of the bot's flow.These variables are similar to the types of variables you'd find in other programming languages and can be used to store data like text, numbers, boolean values, dates, objects, arrays, enums, and patterns. With Botpress variables, you can personalize the user's experience by storing information like their name, preferences, and past interactions with the bot.","types-of-variables#Types of Variables":"You can create variables that can be used at different times in your flow.\nType\tDescription\tString\tValues that are treated as text. This means that the values of string variables may include numbers, letters, or symbols. E.g. useful to store the name of the user.\tBoolean\tVariables can either be True or False. E.g. isGreeted boolean variable checks if the user has been greeted or not\tNumber\tTo store value in number format for storing numeric values such as phone numbers and Pincode.\tDate\tSimple integers representing the number of days, weeks, hours, and so on from a user-specified starting point. E.g. Storing the user's order date for a product.\tObject\tCollection of key-value pairs, each key is mapped to a value. E.g.\tArray\tCollection of similar types of data. There are two types of Arrays. 1. String Storing a list of strings. E.g [Apple, Mango, Banana] 2. Object Storing a list of objects.\tEnum\tUnique set of data. An example of an enum type might be the days of the week or a set of status values for a piece of data.\tPattern\tValue that follows a predefined pattern using regex.","workflow-variables#Workflow Variables":"Workflow Variables are temporary variables that are used to store information during a conversation between the user and the bot. They are created and used within the scope of a single workflow and are not persisted across sessions or conversations.These variables are often used to capture data that is collected during a conversation and used to drive the flow of the conversation. For example, if a user is asked a series of questions, the answers provided by the user can be stored in Workflow Variables and used to determine the next set of questions to ask or actions to take.They can be created and accessed by the bot's programming code, and they are typically used to pass data between different nodes in a workflow or between different workflows. They can also be used to store temporary data such as flags or status indicators that are used to track the progress of a conversation.Since Workflow Variables are temporary and are not persisted between sessions, they are not suitable for storing data that needs to be retained across multiple conversations or for personalizing the user's experience. For that, User Variables would be more appropriate.To create a Variable in your bot's workflow, you can follow these steps:\nSelect the appropriate workflow from the Explorer menu.\nDouble-click on the empty space in the workflow editor to open the Inspector panel.\nIn the Inspector panel, navigate to the flow properties section.\nGive your variable a name, pick a type and click \"Add\" to create the variable.\nYou can also add default(initial) value for a variable from the Additional Settings.\n(Optional) You can use {{workflow.variablename}} or @variablename to display it in your send message card.","user-variables#User Variables":"User Variables are associated with a specific user and are persisted across multiple sessions. This means that if a user interacts with the chatbot multiple times, their User Variables will still be available and can be used to personalize the conversation. Examples of User Variables include user's name, preferences, or history of interactions.You can simply go to Chatbot Settings and add user variables. You can use {{user.variablename}} or @variablename to display it in your send message card.","bot-variables#Bot Variables":"Bot Variables, on the other hand, are the same for all users of the bot. They are typically used to store information that is relevant to the entire chatbot, such as configuration settings or data that is used across multiple conversations. Examples of Bot Variables include the bot's name, version, or any static data that the bot may need to function properly.You can simply go to Chatbot Settings and add bot variables. You can use {{bot.variablename}} or @variablename to display it in your send message card.\n\nBoth User Variables and Bot Variables can be used throughout a chatbot's workflow to provide personalized experiences, make decisions, or trigger specific actions. By properly defining and utilizing these variables, chatbots can become more intelligent, engaging, and effective in their interactions with users.Remember that the scope of your variable will depend on the type of variable you create (User, Bot, or Workflow), and that variables can be used and passed down from one workflow to the next as inputs and outputs of your workflows.","configuration-variables#Configuration Variables":"On the Left Panel in your Botpress Studio, Click the ⚙️ icon to open up Chatbot Settings and go to Variables. You will see an option to add Configuration Variables\nCreate a new Key and add the value that you want to use in your Development environment. Note that this value will should only be used while testing.\nClick save and publish your chatbot.\n\nYou can use {{env.key}} to get the value of the Configuration Variable Key that you've created in step 1.To use it in an Execute Code Card, you can write env.key to access it's value.Learn more on using configuration variables in production.","setting-value-to-a-variable#Setting Value to a Variable":"To assign a value to your variable, you can use the Execute Code card and assign the value. From the Inspector, type in the statement workflow.variableName = value where value is the value you want to assign.For example, if you created the boolean variable greeted, you might want to assign the value true to this variable. In this case, you can use Execute code, and write workflow.greeted = true to give it the true value.Later, you will be able to use this as a transition condition if the user is returning and was already greeted.","displaying-value-of-a-variable#Displaying Value of a Variable":"You can either use {{workflow.variablename}} or @variablename in a text field to display value of a variable."}},"/cloud/studio/workflows":{"title":"Workflows","data":{"":"A flow allows you to break down a complex chatbot into multiple smaller flows. Breaking down the chatbot into multiple flows makes it easier to maintain, and you can re-use these flows when building other flows or even other chatbots.A workflow always starts at its Entry Node At the beginning of each conversation, the Start Node of the Main flow of the Global Topic is the first to be executed. When the conversation reaches a node, Botpress will queue the active node's instructions and execute them in the order they were added to the node.The flow is event-based and non-blocking by default, meaning it will execute all the nodes and instructions until it needs to waitIn other words, once the Entry Node is processed, the flow will continue to proceed to the next node in the flow until it reaches the very end of the flow or until a node needs to “wait” for user input.","global-flows#Global Flows":"Global flows in Botpress are essential components of the chatbot's functionality and cannot be deleted. These flows serve as the foundation for handling various important aspects of the chatbot's behavior and interactions.While you cannot delete global flows, you can modify and customize them to suit your specific needs. You can add new actions, adjust the workflow logic, and incorporate additional functionality within the existing global flows. This allows you to extend the capabilities of the chatbot while maintaining the essential system-level functionality provided by the global flows.","main#Main":"This is the primary conversation path that the chatbot follows in order to achieve its main purpose.For example, if the chatbot is designed to provide customer service for a particular product, the Main Flow would include steps to gather information about the customer's issue, provide potential solutions, and ultimately resolve the problem.The Main Flow is typically the most detailed and complex flow in the chatbot's design, as it needs to account for a wide range of possible inputs and scenarios.","error#Error":"The Error Flow is designed to handle unexpected user inputs that don't fit within the parameters of the Main Flow.This can include misspelled or misunderstood words, off-topic questions, or input that doesn't make sense in the context of the conversation.The Error Flow should provide clear feedback to the user that their input was not understood and prompt them to provide more specific or relevant information.Depending on the design of the chatbot, the Error Flow may offer suggestions for alternative input, or it may direct the user to a specific resource or human representative for further assistance.","timeout#Timeout":"The Timeout Flow is triggered when the chatbot doesn't receive a response from the user for a certain period of time.This can happen if the user is distracted or if there is a delay in their internet connection.The Timeout Flow should provide a prompt or question to the user to encourage them to continue the conversation, and it may also include a message explaining why the chatbot has paused the conversation.The Timeout Flow is important because it helps prevent the chatbot from appearing unresponsive or disconnected, which can lead to user frustration and disengagement.","conversation-end#Conversation End":"The Conversation End Flow is designed to wrap up the conversation in a way that feels natural and satisfying to the user.Depending on the context and purpose of the chatbot, this may involve thanking the user for their input and inviting them to provide feedback or continue the conversation later, or it may involve providing specific next steps for the user to take.The Conversation End Flow is an important part of the chatbot design, as it helps create a positive user experience and encourages users to return in the future.","custom-workflow#Custom Workflow":"It's important to note that you can create and manage custom workflows alongside the global flows to implement specific business logic and custom behavior. This way, you can enhance the chatbot's functionality without compromising the integrity of the global flows.By clicking on the \"Add Workflow\" icon located at the top of the Explorer Menu, you gain the ability to create custom workflows for your chatbot. Workflows are a crucial aspect of chatbot development as they define the logic and flow of conversations between the bot and its users.Creating custom workflows allows you to tailor the behavior of your chatbot according to your specific requirements and use cases.Here are some key benefits and possibilities of creating custom workflows:\nDesigning Conversational Flows: Workflows enable you to design conversational flows that guide the interaction between the chatbot and users. You can define the sequence of messages, questions, and responses to create engaging and meaningful conversations.\nImplementing Business Logic: Custom workflows empower you to incorporate complex business logic into your chatbot. You can define conditions, triggers, and actions based on user inputs or specific events to provide dynamic and context-aware responses.\nIntegration with External Systems: Workflows allow you to integrate your chatbot with external systems and APIs. You can utilize custom workflows to fetch data from databases, invoke web services, or perform any other necessary operations to enrich the user experience and provide relevant information.\nHandling User Input: With custom workflows, you can capture and process user input in a structured manner. You can define prompts, validate input, and handle different scenarios based on user responses, ensuring a smooth and interactive conversation flow.\nImplementing Advanced Features: Custom workflows enable you to implement advanced features such as user authentication, session management, context preservation, and more. These features enhance the functionality and capabilities of your chatbot, allowing for a more sophisticated user experience.","execute-workflow#Execute Workflow":"After building a few flows, you'll quickly notice that there are some common patterns that you find yourself implementing over and over. These can be seen as reusable components between multiple flows. So, you can create Folders to categorise your workflows.Once you have created your workflow, right-click in the Flow Editor, hover over the Execute Workflow option and select your workflow.","workflow-variables#Workflow Variables":"Learn more about using workflow variables"}},"/cloud/toolbox/ai-task":{"title":"AI Task","data":{"":"Generative AI Task\nThe AI Task Card in Botpress is designed to enable users to perform tasks\nusing generative artificial intelligence.\nIt is a tool for generating content using Artificial Intelligence and can be used to automate a wide range of tasks. By providing clear instructions, specific inputs, and well-named variables, users can leverage the full capabilities of this tool to improve their workflows and boost their productivity.","task-instructions#Task Instructions":"To accomplish a generative task using the AI Task Card, users will need to provide specific instructions in natural language\non what they want the AI engine to generate. This can be done using the Task Instructions parameter.\n\nUsers should provide a clear and detailed description of the task they want the AI\nengine to perform, including any relevant constraints or guidelines that should be\nfollowed.","ai-task-input#AI Task Input":"This is the input that will be sent to the Generative AI Engine. Think of it as the problem subject. Users should be as specific as possible when providing the AI task input, as this will help the AI engine generate more accurate and relevant content.\nYou can use multiple variants as an input - not limited to:\n\n\nType\n\nDescription\n\n\n\n{{event.preview}}\n\nthat will use the last value sent to the bot as input to the AI Task.\n\n\n\n{{workflow.variableName}}\n\nwhere the variableName is a variable you have previously defined in this workflow and you want to use as an input to the AI Task.\n\n\n\n{{user.propertyName}}\n\nwhere the propertyName is the user property we want to use as an input to the AI Task.\nIn addition to free text, depending on your use case and what you are trying to achieve.","storing-result-in-variables#Storing result in variables":"This allows users to specify the variables where the extracted information will be stored within Botpress. It is important to choose variable names that are easy to understand and identify, as these variables will be used to reference the generated content in other parts of the Botpress workflow and it will influence the AI task on what to extract and how.","task-example#Task Example":"","example-input#Example Input":"By providing clear and realistic examples, you can help the AI better understand its task and be used\nto solve real-world problems and generate useful content. This can ultimately lead to a more successful and productive experience\nfor users who are targeting the power of artificial intelligence in their workflows.\n\nThe Task Example allows you to provide example text that the AI Task can expect to\nreceive from the user, as well as examples of the outputs the AI Task should generate\nas a response. These examples help the AI Task to better understand the instruction\nthat was provided to it as well as its output format.","displaying-result-optional#Displaying result (optional)":"You still need a content-type card to display the output of the AI Task Card if you want to.","advanced-settings#Advanced Settings":"","temperature#Temperature":"Temperature is a setting that controls how creative and varied the responses generated by an AI language model can be. Think of it like a dial that you can turn up or down to control how much the AI is allowed to come up with new and different responses. It ranges from 0 to 1.When the temperature is set to 0, the AI will stick to the same answer most of the time, which can be useful for tasks that require consistency and accuracy. However, if you want more creative and varied responses, you can turn up the temperature, and the AI will come up with more diverse answers that may not always be the same.For example, if you ask the LLM \"What is your favorite animal?\", with a temperature of 1 it might respond with \"My favorite animal is a cat because they are cute and cuddly\", but it might also generate a response like \"My favorite animal is a platypus because they're such odd creatures and so unique\". Both responses are consistent with the LLM's training data (which includes information about cats and platypuses), but the second response is more creative and unexpected.In simpler terms, temperature is a way to control how much \"imagination\" the AI has when generating responses. A lower temperature means more consistency, while a higher temperature means more creativity and variability.","ai-prompt-chaining#AI Prompt Chaining":"Prompt chaining is connecting multiple AI Task Cards together in a workflow, where the output of one AI Task Card becomes the input for the next. This can be a powerful technique for generating complex content, as it allows users to break down a large generative task into smaller, more manageable pieces.Other practical examples would include the following:\nGenerating a full product description by chaining together separate AI Task Cards for the product name, features, benefits, and specifications\nCreating a personalised email campaign by chaining together AI Task Cards for recipient names, email subject lines, and body text\nGenerating a complex chatbot response by chaining together AI Task Cards for intent recognition, entity extraction, and response generation\n\n\n\nPrompt chaining can also help to improve the accuracy and relevance of generated\ncontent, as each AI Task Card can be optimized to perform a specific task, and the\noutput of one AI Task Card can be used to inform the input of the next.Finally, here are some guidelines and best practices for prompt chaining effectively in Botpress:\nBreaking down large generative tasks into smaller, more manageable pieces\nTesting each AI Task Card individually before chaining them together\nEnsuring that the output of each AI Task Card is formatted correctly to be used as input for the next\nChoosing the right variables names for the extracted information so they can be easily referenced in the chain"}},"/cloud/toolbox/execute-code":{"title":"Execute Code","data":{"":"This instruction is to execute custom code in a node. For example, fetching and displaying a user-submitted city’s weather information using an API.\nGenerative AI\nUsing natural language you can instruct AI to generate the needed code for your bot.\nExample 1:\"I want to find the difference between the variables startDate and the endDate\"Generated Output:\n\n\n\nExample 2:\"I want to get all my issues from Jira filtered by what is not done\"Generated Output:","advanced#Advanced":"You can build your own code here, using below node packages:\nAxios\nLodash\nMoment Luxon\n\nUsing the above packages, you will be able fetch and display the user-submitted city's weather information using an API."}},"/cloud/toolbox/capture-information":{"title":"Capture Information\"","data":{"":"Capture Information Card is part of the Toolbox that allows the bot to stop processing and wait for the user's response while capturing a specific piece of information from the user's input.This could include details like the user's name, full address, or raw input.To collect multiple pieces of information, multiple prompt fields can be added to a single prompt node. Once the information is collected, a flow variable should be created to store the extracted information for later use in the conversation or to be passed on to other systems. This allows for a more personalized and efficient experience for the user, as well as providing valuable data for the chatbot's developers.","prompt-field-types#Prompt Field Types":"A Prompt Field is a type of input field that is used to capture information from a user in a structured and organized manner. It can include various types of input fields such as Single Choice, Multiple Choice, Number, Email Address, Phone Number, and more.The Prompt Field also includes validation messages and code validation, which helps ensure that the user inputs the correct type of information. This means that if the user inputs an invalid value, they will be notified with an error message and prompted to re-enter the correct information.\n\nHere's the list of all the Prompt Fields available in Capture Information Card.\n\n\nPrompt Fields\n\nDescription & Extracted Information\n\n\n\nSingleChoice\n\nExtracts a Single Choice from a finite list of possible Values\nVariable Type: Boolean\n\n\n\nMultipleChoice\n\nExtracts one or multiple choices from a finite list of possible Values\nVariable Type: Boolean\n\n\n\nBoolean\n\nExtract a Boolean (On/Off) from the Query\nVariable Type: Boolean\n\n\n\nConfirmation\n\nConfirm a Yes/No question with a Boolean from the Query\nVariable Type: Boolean\n\n\n\nNumber\n\nExtracts a Number from the Query\nVariable Type: Boolean\n\n\n\nEmailAddress\n\nExtracts a full Email Address from the Query\nVariable Type: Boolean\n\n\n\nPhoneNumber\n\nExtracts a Telephone Number and optionally the Country Code from the Query\nVariable Type: Boolean\n\n\n\nFullAddress\n\nExtract the Full Address from the Query\nVariable Type: Boolean\n\n\n\nPrice\n\nExtracts a Price from the Query\nVariable Type: Boolean\n\n\n\nRawInput\n\nExtract the Input provided by the User, without any processing\nVariable Type: Boolean\n\n\n\nPercentage\n\nExtracts a Percentage from the Query\nVariable Type: Boolean\n\n\n\nQuantity\n\nExtract a Quantity from a Query\nVariable Type: Boolean\n\n\n\nColor\n\nExtracts a Color as both HEX and RGB codes from the Query\nVariable Type: Boolean\n\n\n\nTimeMeasurement\n\nExtracts a time measurement as (ns, mu, ms, s, min, h, d, week, month,\nyear) Units\nVariable Type: Boolean\n\n\n\nWeightMeasurement\n\nExtracts a Weight Measurement as (mcg, mg, g, kg, oz, lb, mt, t) Units\nVariable Type: Boolean\n\n\n\nCronSchedule\n\nExtracts a one-time or recurring schedule as a CRON Expression from the\nQuery\nVariable Type: Boolean\n\n\n\nOperatingSystem\n\nExtracts the name of an Operating System (Windows, OSX, IOS, Android,\nLinux)\nVariable Type: Boolean\n\n\n\nQuantityofPeople\n\nExtracts the Number of People in a Query\nVariable Type: Boolean\n\n\n\nVolumeMeasurement\n\nExtracts a volume measurement as (mm3, cm3, ml, l, kl, m3, km3, tsp, Tbs,\nin3, fl-oz, cup, pnt, qt, gal, ft3, yd3) Units\nVariable Type: Boolean\n\n\n\nTemperatureMeasurement\n\nExtracts a Temperature Measurement as (C, K, F) Units\nVariable Type: Boolean\n\n\n\nPerson\n\nExtracts the name of a person(first and last names)\nVariable Type: Object\n\n\n\nDateTime\n\nExtracts date and time relative to the current date\nVariable Type: Object\n\n\n\n\nLet's understand each prompt field in detail.","single-choice#Single Choice":"The Single Choice is a type of input field that presents the user with a list of options to choose from. The user can only select one option from the list, and their choice is then stored as a value in a variable. This variable can be used later in your workflow for further processing.An example of Single Choice would be a survey question with multiple options, where the user selects one answer from the list.","steps-to-use-single-choice-field#Steps to use Single Choice Field":"Create a new capture information card.\nSet the Type property to Single Choice.\nSet the Variable name property to the name of the workflow variable you want to use to store the selected option.\nSet the Prompt message property to a message that lists the available options for the user to choose from.\nClick on the Advanced Configuration to add Choices.\n\nOnce the card is used, it will present the available options to the user and allow them to select only one. The selected option will be saved in the workflow variable you specified, and you can use it in other parts of your workflow to make decisions or take actions based on the user's choice.","example#Example":"Let's say you want to ask the user about their preferred mode of transportation, and you have three options: car, bus, and bike. You can create a new capture information card with the following properties:\n\nWhen the user selects their preferred mode of transportation, the Single Choice card will save the value in the preferredTransportation workflow variable. You can then use this variable to tailor the conversation based on the user's choice.For example, if they choose bike, you can ask follow-up questions related to biking or suggest some scenic bike routes.You can also use the value of the preferredTransportation variable in transitions. For example, if the user selects car, you can move them to a node related to car-related services or if they choose bus, you can move them to a node related to public transportation schedules.","multi-choice#Multi Choice":"The Multi Choice type is a way to gather information from users by presenting them with a list of options to choose from. Users can select one or more options from the list.This type of capture information is useful in scenarios where you want to give users a set of choices to pick from, like selecting the toppings for a pizza or the colors for a shirt. It's a quick and easy way to collect information from users without having to ask them to type out their answers.","steps-to-use-multi-choice-field#Steps to use Multi Choice Field":"Create a new capture information card.\nSet the Type property to Multi Choice.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted values.\nSet the Prompt message property to a message that provides a list of choices for the user to select from.\nClick on the Advanced Configuration to add Choices.\n\nOnce the card is used, it will extract the selected options from the user's input and save them in the workflow variable you specified. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's response.","example-1#Example":"Let's say you want to ask the user what toppings they want on their pizza. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Multi Choice card will extract the selected options and save them in the pizzaToppings workflow variable. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's response.For example, if the user selects pepperoni and mushrooms, you can use the pizzaToppings variable to customise their order and display a message like Your pizza with pepperoni and mushrooms is on the way!","boolean#Boolean":"Boolean type extracts a binary value from the user's input and saves it in a variable of type boolean. The extracted information can include values like true and false, agree and disagree, accept and decline, or any other binary values.","steps-to-use-boolean-field#Steps to use Boolean Field":"Create a new capture information card.\nSet the Type property to Boolean.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted boolean value.\nSet the Prompt message property to a message that prompts the user to enter a binary value.\nOptionally, you can edit the Choices property if you want to customize the binary values that the user can select. By default, the choices are Yes and No. When the user provides an input, the system will extract either a true or false value based on whether the user selects Yes or No.","example-2#Example":"Let's say you want to ask the user if they agree to the terms and conditions of service. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Boolean card will extract the binary value and save it in the agreeToTerms workflow variable as either true or false. You can then use this variable in other parts of your workflow to decide whether to proceed with the service or not.If the user agrees to the terms and conditions, you can submit their request or move them to the next node, but if they disagree, you can say something like 'Sorry to hear that' and end the conversation. This will display a message based on the user's response and whether they agreed to the terms and conditions or not.","confirmation#Confirmation":"The Confirmation type is a way to ask the user to confirm or agree to something. For example, you might use this type to confirm a user's purchase, agreement to terms and conditions, or confirmation of an appointment. When the user responds, the Confirmation type extracts a binary value (either true or false) and saves it in a variable. This allows you to use the user's confirmation or agreement later in your bot's logic.","steps-to-use-confirmation-field#Steps to use Confirmation Field":"Create a new capture information card.\nSet the Type property to Confirmation.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted boolean value.\nSet the Prompt message property to a message that prompts the user to confirm or agree to something.\nOptionally, you can edit the Choices property if you want to customize the binary values that the user can select. By default, the choices are Accept and Decline. When the user provides an input, the system will extract either a true or false value based on whether the user selects Accept or Decline.\n\nOnce the card is used, it will automatically extract the confirmation from the user's input and save it in the workflow variable you specified as a boolean value (true or false). You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's confirmation.","example-3#Example":"Let's say you want to ask the user if they want to proceed with a purchase. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Confirmation card will extract the confirmation and save it in the proceedWithPurchase workflow variable as either true or false. You can then use this variable in other parts of your workflow to decide whether to proceed with the purchase or not.If the user confirms they want to proceed with the purchase, you can move them to the payment process node, but if they decline, you can say something like 'No problem, maybe next time!' and end the conversation. This will display a message based on the user's response and whether they confirmed to proceed with the purchase or not.","number#Number":"TheNumber type extracts a numerical value from the user's input and saves it in a variable of type number.The user can enter any numerical value, like a whole number or a decimal, and the bot will recognize and store it as a number. This can be used for calculations or any other purpose where a numerical value is needed.","steps-to-use-number-field#Steps to use Number Field":"Create a new capture information card.\nSet the Type property to Number.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted numerical value.\nSet the Prompt message property to a message that prompts the user to enter a numerical value.\n\nOnce the card is used, it will automatically extract the numerical value from the user's input and save it in the workflow variable you specified as a numerical value (integer or decimal). You can then use this variable in other parts of your workflow to perform calculations or take actions based on the user's response.","example-4#Example":"Imagine you are creating an online store that sells products to customers. You want to ask the user to enter the quantity of a certain product they want to purchase. To do this, you can create a form with a field that uses the Number type to capture the user's input.For example, you can create a field with the following details:\n\nWhen the user enters their response, the Number field will extract the numerical value and save it in the productQuantity variable as either an integer or decimal value. You can then use this variable in other parts of your workflow to calculate the total cost of the purchase.For instance, if the product costs $10 per unit and the user entered 3 as the product quantity, you can calculate the total cost in an Execute Code Card as follows:\n\nThis will enable you to calculate the total cost of the purchase based on the user's input and display it to the user before they confirm their order.","email-address#Email Address":"The EmailAddress type is used to extract an email address value from the user's input and save it in a variable of type string. This allows you to use the extracted email address in other parts of your bot's logic, such as sending an email confirmation or storing the email address for future use. The email address can be in any valid email address format, including with special characters such as dots, hyphens, and underscores.","steps-to-use-email-address-field#Steps to use Email Address Field":"Create a new capture information card.\nSet the Type property to EmailAddress.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted email address value.\nSet the Prompt message property to a message that prompts the user to enter an email address.\n\nOnce the card is used, it will automatically extract the email address value from the user's input and save it in the workflow variable you specified as a string value. You can then use this variable in other parts of your workflow to send emails or perform other actions based on the user's response.","example-5#Example":"Let's say you want to ask the user for their email address so that you can send them a newsletter. You can create a new capture information card with the following properties:\n\nWhen the user enters their email address, the EmailAddress card will extract the value and save it in the userEmail workflow variable as a string. You can then use this variable in other parts of your workflow to add the user to your newsletter subscription list or perform other actions based on the user's response.","phone-number#Phone Number":"In this section, we'll discuss the PhoneNumber capture information type in Botpress. This type of capture information extracts only the phone number representing the user's input, excluding the country code, and saves it in a variable of type string.","steps-to-use-phone-number-field#Steps to use Phone Number Field":"Create a new capture information card.\nSet the Type property to PhoneNumber.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted phone number value.\nSet the Prompt message property to a message that prompts the user to enter a phone number.\n\nOnce the card is used, it will automatically extract the phone number from the user's input and save it in the workflow variable you specified as a string value. The extracted information will not include the country code, only the digits representing the phone number. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's phone number.","example-6#Example":"Let's say you want to ask the user for their phone number to schedule a call with them. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the PhoneNumber card will extract the digits representing the phone number and save it in the userPhoneNumber workflow variable as a string. You can then use this variable in other parts of your workflow to schedule a call with the user.","fulladdress#FullAddress":"FullAddress extracts the full address information from the user's input and saves it in a variable of type object. The extracted information contains the country, city, street, zip code, and house number.","steps-to-use-full-address-field#Steps to use Full Address Field":"Create a new capture information card.\nSet the Type property to FullAddress.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted address information.\nOptionally, set the Prompt message property to a message that prompts the user to enter their address.\nSave the card.\n\nOnce the card is saved, it will automatically extract the full address information from the user's input and save it in the workflow variable you specified. You can then use this variable in other parts of your workflow by referencing the specific fields in the address object using the following syntax: {{workflow.variableName.country}}, {{workflow.variableName.city}}, {{workflow.variableName.street}}, {{workflow.variableName.zip}}, and {{workflow.variableName.number}}.","example-7#Example":"Let's say you want to capture the user's full address to use in a shipping process. You can create a new capture information card with the following properties:\n\nWhen the user enters their address, the FullAddress card will extract the information and save it in the shippingAddress workflow variable. You can then use this variable in other parts of your workflow to complete the shipping process, such as sending an email confirmation to the user with their shipping details.Here's an example of how you can use the extracted information in a message:\n\nThis will display the user's full address in a clear and easy-to-read format for both the user and the bot.","price#Price":"Price extracts the price information from the user's input and saves it in a variable of type number. The extracted information contains the amount of money, regardless of the currency.","steps-to-use-price-field#Steps to use Price Field":"Create a new capture information card.\nSet the Type property to Price.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted price information.\nSet the Prompt message property to a message that prompts the user to enter the price.\nOptionally, set the Default value property to a default price to be used if the user doesn't provide one.\nSave the card.\n\nOnce the card is saved, it will automatically extract the price information from the user's input and save it in the workflow variable you specified. You can then use this variable in other parts of your workflow to perform calculations or other operations that require the price information.","example-8#Example":"Let's say you want to capture the user's price information to process a payment. You can create a new capture information card with the following properties:\n\nWhen the user enters the price, the Price card will extract and save the information in the paymentAmount workflow variable. You can then use this variable in other parts of your workflow to process the payment, such as sending the payment information to a payment gateway.Here's an example of how you can use the extracted information in a message:\n\nThis will display the user's payment amount in a clear and easy-to-read format for both the user and the bot.","raw-input#Raw Input":"The RawInput extracts the user's input as it is and saves it in a variable of type string. The extracted information can include any type of user input, including text, numbers, and special characters.","steps-to-use-raw-input-field#Steps to use Raw Input Field":"Create a new capture information card.\nSet the Type property to Raw Input.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted user input.\nSet the Prompt message property to a message that prompts the user to enter their input.\n\nOnce the card is used, it will automatically extract the user's input and save it in the workflow variable you specified as a string value. You can then use this variable in other parts of your workflow to process the user's input or display it back to them.","example-9#Example":"Let's say you want your users to submit an issue for your product. You can create a new capture information card with the following properties:\n\nWhen the user enters the issue description, the Raw Input card will extract the user's input and save it in the issueDescription workflow variable as a string value. You can then use this variable in other parts of your workflow to log the issue or escalate it to the relevant team for resolution.You can create a message node with the following text:\n\nThis will acknowledge the issue and provide the user with an estimated time frame for resolution.","percentage#Percentage":"The Percentage extracts the decimal representing the percentage the user is using from the user's input and saves it in a variable of type number. The extracted information can include values like 50%, 75%, or any other percentage.","steps-to-use-percentage-field#Steps to use Percentage Field":"Create a new capture information card.\nSet the Type property to Percentage.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted percentage value.\nSet the Prompt message property to a message that prompts the user to enter a percentage.\n\nOnce the card is used, it will automatically extract the decimal value representing the percentage from the user's input and save it in the workflow variable you specified as a number value. You can then use this variable in other parts of your workflow to make calculations or take actions based on the user's response.","example-10#Example":"Let's say you want to ask the user what percentage discount they would like to apply to their purchase. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Percentage card will extract the decimal value representing the percentage and save it in the discountPercentage workflow variable as a number. You can then use this variable in other parts of your workflow to calculate the discount or take actions based on the user's desired discount.For example, if the user entered 50%, you could calculate the discount amount as follows:\n\nThis will calculate the discount amount based on the user's desired discount percentage and the total price of the purchase.","quantity#Quantity":"The Quantity extracts the quantity information from the user's input and saves it in a variable of type number. For example, if the user inputs \"I want to buy 5 apples\" or \"Give me 5 kilograms of apples\", the function will extract the number 5 and store it as a numerical value, without regard to the different units of measurement used. This allows you to work with the quantity of the item, regardless of how the user expressed it.","steps-to-use-quantity-field#Steps to use Quantity Field":"Create a new capture information card.\nSet the Type property to Quantity.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted quantity information.\nSet the Prompt message property to a message that prompts the user to enter the quantity.\n\nOnce the card is saved, it will automatically extract the quantity information from the user's input and save it in the workflow variable you specified. You can then use this variable in other parts of your workflow by referencing it using the following syntax: **{{workflow.variableName}}**.","example-11#Example":"Let's say you want to capture the user's desired quantity of a product. You can create a new capture information card with the following properties:\n\nWhen the user enters a valid quantity, the Quantity card will extract and save the information in the productQuantity workflow variable as a number. You can then use this variable in other parts of your workflow to calculate the total price or to check the stock availability.Here's an example of how you can use the extracted information in a message:\n\nThis will display the total price to the user based on the quantity they entered and the price of the product.","color#Color":"The Color type extracts the color information from the user's input and saves it in a variable of type object. The extracted information contains the colour name, hexadecimal code, and RGB values.","steps-to-use-color-field#Steps to use Color Field":"Create a new capture information card.\nSet the Type property to Color.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted colour information.\nSet the Prompt message property to a message that prompts the user to enter a colour.\n\nOnce the card is called will automatically extract the colour information from the user's input and save it in the workflow variable you specified. You can then use this variable in other parts of your workflow by referencing the specific fields in the colour object using the following syntax: {{workflow.variableName.colorName}}, {{workflow.variableName.hexCode}}, and {{workflow.variableName.rgb}}.","example-12#Example":"Let's say you want to capture the user's favourite colour to use in a marketing campaign. You can create a new capture information card with the following properties:\n\nWhen the user enters their favourite colour, the Color card will extract the information and save it in the favoriteColor workflow variable. You can then use this variable in other parts of your workflow to customise your marketing campaigns, such as using the colour in promotional materials or emails.Here's an example of how you can use the extracted information in a message:\n\nThis will display the user's favourite colour and its associated information in a personalised message, making the interaction with the bot more engaging and memorable.","time-measurement#Time Measurement":"The TimeMeasurement type extracts date/duration values from the user's input and save it in a variable of type Number after converting it to the chosen format. The extracted information can include values like next week, in a month, after two months, in 15 days, in 2 working days, etc. This information can be useful for scheduling appointments, setting reminders, and much more.","steps-to-use-time-measurement-field#Steps to use Time Measurement Field":"Create a new capture information card.\nSet the Type property to Time Measurement.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted time measurement value.\nSet the Prompt message property to a message that prompts the user to enter a date/duration value.\n\nOnce the card is used, it will automatically extract the date/duration value from the user's input and save it in the workflow variable you specified as a number value. The time measurement value will be converted to the chosen format (nanoseconds, microseconds, milliseconds, seconds, minutes, hours, days, weeks, months, or years). You can then use this variable in other parts of your workflow to schedule appointments or set reminders.","available-formats#Available Formats":"The following formats are available for the extracted time measurement value:ns (nanoseconds)\nmu (microseconds)\nms (milliseconds)\ns (seconds)\nmin (minutes)\nh (hours)\nd (days)\nweek (weeks)\nmonth (months)\nyear (years)You can choose any of these formats based on your requirement.","example-13#Example":"Let's say you want to schedule a meeting with a user based on their availability. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Time Measurement card will extract the time measurement value and save it in the meetingTime workflow variable as a number value in the chosen format. You can then use this variable in other parts of your workflow to schedule the meeting accordingly.If the user is available at the specified time, you can schedule the meeting and confirm the details with the user. If not, you can ask for their availability again.This will allow you to schedule meetings with users based on their availability and improve their experience with your service.","weight-measurement#Weight Measurement":"The WeightMeasurement extracts weight information from the user's input and saves it in a variable of type number after converting it to the chosen format. The available formats are mcg, mg, g, kg, mt, oz, lb, t.","steps-to-use-weight-measurement-field#Steps to use Weight Measurement Field":"Create a new capture information card.\nSet the Type property to Weight Measurement.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted weight value.\nSet the Prompt message property to a message that prompts the user to enter a weight.\n\nOnce the card is used, it will automatically extract the weight information from the user's input and save it in the workflow variable you specified as a number value. The value is converted to the chosen format which is selected during the configuration of the card. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's response.","available-formats-1#Available Formats":"The available weight measurement formats are:\n\n\nmcg (microgram)\n\nmg (milligram)\n\ng (gram)\n\nkg (kilogram)\n\n\n\nmt (metric ton)\n\noz (ounce)\n\nlb (pound)\n\nt (ton)","example-14#Example":"Let's say you want to ask the user for their weight in kilograms. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Weight Measurement card will extract the weight information and convert it to kilograms, saving it in the userWeight workflow variable as a number value. You can then use this variable in other parts of your workflow to decide what to do based on the user's response.You can ask the user if they want to proceed if their weight is over a certain limit or if it falls under a certain range. You can also display the weight measurement in different formats by using a formatted node.This will display the user's weight in the desired format and provide relevant information based on their response.","cron-schedule#Cron Schedule":"The CronSchedule type takes a specific interval of time that a user inputs and convert it into a format that a computer program can understand. This interval can be things like every 5 minutes or once a day at 3pm.The Cron Schedule then saves this interval in two ways: first, in a format that follows the Cron convention (which is a standard way of representing time intervals in programming); and second, as a boolean value that indicates whether the interval should be repeated or not (for example, if the interval is \"every 5 minutes,\" the Cron Schedule would set the repeatable property to true, whereas if the interval is \"once a day at 3pm,\" the Cron Schedule would set the repeatable property to false).This makes it easier for developers to program applications that need to run certain tasks at specific intervals of time.","steps-to-use-cron-schedule-field#Steps to use Cron Schedule Field":"Create a new capture information card.\nSet the Type property to Cron Schedule.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted cron interval.\nSet the Prompt message property to a message that prompts the user to enter the desired interval value.\n\nOnce the card is used, it will automatically extract the interval value from the user's input and save it in the workflow variable you specified as an object containing the cron interval and the repeatable boolean value.","example-15#Example":"Let's say you want to ask the user for a cron schedule to trigger a certain event. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Cron Schedule card will extract the interval value and save it in the cronSchedule workflow variable as an object with two properties: the cron value, which represents the extracted interval in a cron format, and the repeatable boolean value, which indicates whether the interval should be repeated or not.You can then use this variable in other parts of your workflow to set up the event trigger according to the user's input.","operating-system#Operating System":"The OperatingSystem type extracts the operating system the user is using from their input and saves it in a variable of type object. This information can be useful for troubleshooting issues specific to certain operating systems or for tailoring responses based on the user's operating system.","steps-to-use-operating-system-field#Steps to use Operating System Field":"Create a new capture information card.\nSet the Type property to Operating System.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted operating system.\nSet the Prompt message property to a message that prompts the user to enter their operating system.\n\nOnce the card is used, it will automatically extract the operating system from the user's input and save it in the workflow variable you specified as an object. The extracted information can include the name and version of the operating system.","example-16#Example":"Let's say you want to ask the user about the operating system they are using to access your website. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Operating System card will extract the information and save it in the userOS workflow variable as an object that includes the name and version of their operating system.You can then use this variable in other parts of your workflow to tailor responses or troubleshoot issues specific to their operating system.","quantity-of-people#Quantity of People":"The QuantityofPeople type extracts a number representing the quantity of people from the user's input and saves it in a variable of type Number. The extracted information can include values like 1, 2, 3, and so on.For example, if you are building a reservation system for a restaurant, you can use the QuantityofPeople type to ask the user how many people will be dining, and then save that number as a variable. This variable can then be used to ensure that the restaurant has enough seats available for the group, or to calculate the total cost of the meal based on the number of people.","steps-to-use-quantity-of-people-field#Steps to use Quantity of People Field":"Create a new capture information card.\nSet the Type property to QuantityofPeople.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted number value.\nSet the Prompt message property to a message that prompts the user to enter a number representing the quantity of people.\n\nOnce the card is used, it will automatically extract the number value from the user's input and save it in the workflow variable you specified as a number. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's response.","example-17#Example":"Let's say you want to ask the user how many people will be attending an event. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Quantity Of People card will extract the number value and save it in the numberOfAttendees workflow variable. You can then use this variable in other parts of your workflow to decide how many seats to reserve or how much food to order.If the user enters a number greater than the available seats or food quantity, you can respond with something like 'Sorry, we don't have enough seats/food for that many people' and ask the user to enter a smaller number.This will display a message based on the user's response and the availability of seats or food.","volume-measurement#Volume Measurement":"The VolumeMeasurement extracts a volume value from the user's input and saves it in a variable of type number. The extracted value can be converted to one of the several available formats based on the user's choice.","steps-to-use-volume-measurement-field#Steps to use Volume Measurement Field":"Create a new capture information card.\nSet the Type property to VolumeMeasurement.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted volume value.\nSet the Prompt message property to a message that prompts the user to enter a volume value.\n\nOnce the card is used, it will automatically extract the volume value from the user's input and save it in the workflow variable you specified as a number value. You can then use this variable in other parts of your workflow to perform calculations or use the value in responses to the user.","available-formats-2#Available Formats":"The following volume formats are available for conversion:\n\n\nCubic millimeters (mm3)\n\nCubic centimeters (cm3)\n\nMilliliters (ml)\n\nCentiliters (cl)\n\n\n\nDeciliters (dl)\n\nLiters (l)\n\nKiloliters (kl)\n\nCubic meters (m3)\n\n\n\nCubic kilometers (km3)\n\nTeaspoons (tsp)\n\nTablespoons (Tbs)\n\nCubic inches (in3)\n\n\n\nFluid ounces (fl-oz)\n\nCups (cup)\n\nPints (pnt)\n\nQuarts (qt)\n\n\n\nGallons (gal)\n\nCubic feet (ft3)\n\nCubic yards (yd3)","example-18#Example":"Let's say you want to ask the user about the volume of a liquid they want to order. You can create a new capture information card with the following properties:\n\nThe Volume Measurement type extracts the volume value and save it in the liquidVolume workflow variable as a number value. The value will be converted to the format specified by the user. You can then use this variable in other parts of your workflow to perform calculations or use the value in responses to the user.For example, you could use the liquidVolume variable to calculate the price of the liquid based on the volume and price per unit of volume, or you could use it in response to the user like Thank you for ordering {{workflow.liquidVolume}} ml of liquid. Your order will be delivered soon.","temperature-measurement#Temperature Measurement":"The TemperatureMeasurement type extracts a temperature value from the user's input and saves it in a variable of type Number. The extracted temperature can be in any of the available formats: Celsius, Kelvin, or Fahrenheit.","steps-to-use-temperature-measurement-field#Steps to use Temperature Measurement Field":"Create a new capture information card.\nSet the Type property to Temperature Measurement.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted temperature value.\nSet the Prompt message property to a message that prompts the user to enter a temperature value in any of the available formats.\n\nOnce the card is used, it will automatically extract the temperature value from the user's input, convert it to the chosen format, and save it in the workflow variable you specified as a number. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's response.","available-formats-3#Available Formats":"There are three temperature formats available in the TemperatureMeasurement capture information type. These are: Celsius (°C), Kelvin (K) & Fahrenheit (°F)You can choose the format you want to use in the prompt message property of the capture information card.","example-19#Example":"Let's say you want to ask the user for their body temperature. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Temperature Measurement card will extract the temperature value, convert it to the specified format, and save it in the bodyTemperature workflow variable as a Number. You can then use this variable in other parts of your workflow to decide what action to take based on the user's body temperature.If the user's body temperature is higher than the normal range, you can send them to a doctor's appointment node. If not, you can proceed with the conversation as usual.This will display a message based on the user's response and the action you decide to take based on their body temperature.","person#Person":"The Person type is used to extract the name of a person from the user's input, such as when you ask the user for the name of a contact or a customer. Once the user enters the name, the Person type extracts the first and last names and saves them in a variable of type Object.This extracted information can be used in other parts of your workflow to personalize messages or perform actions specific to that person, such as sending them an email or adding them to a mailing list.","steps-to-use-person-field#Steps to use Person Field":"Create a new capture information card.\nSet the Type property to Person.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted name information.\nOptionally, set the Prompt message property to a message that prompts the user to enter their name.\nSave the card.\n\nOnce the card is saved, it will automatically extract the person's name information from the user's input and save it in the workflow variable you specified.You can then use this variable in other parts of your workflow by referencing the specific fields in the name object using the following syntax:","example-20#Example":"Let's say you want to capture the user's name to personalise a message. You can create a new capture information card with the following properties:\n\nWhen the user enters their name, the Person card will extract and save the information in the userName workflow variable. You can then use this variable in other parts of your workflow to personalise your messages, such as greeting the user by name.Here's an example of how you can use the extracted information in a message:\n\nThis will display a personalised greeting to the user with their first name.","datetime#DateTime":"The DateTime capture information type in Botpress. This type of capture information extracts a date or duration value from the user's input and saves it in a variable of type Object. The extracted information can include values like next week, in a month, after two months, in 15 days, 2 working days, or any other date or duration value.","steps-to-use-datetime-field#Steps to use DateTime Field":"Create a new capture information card.\nSet the Type property to Datetime.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted date or duration value.\nSet the Prompt message property to a message that prompts the user to enter a date or duration value.\n\nOnce the card is used, it will automatically extract the date or duration value from the user's input and save it in the workflow variable you specified as an object. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's response.","example-21#Example":"Let's say you want to ask the user for their preferred date of booking a hotel room. You can create a new capture information card with the following properties:\n\nWhen the user enters their response, the Datetime card will extract the date or duration value and save it in the bookingDate workflow variable as an object. You can then use this variable in other parts of your workflow to decide when to book the room or provide available dates for the user to choose from.You can check the user's preferred booking date against your available dates to ensure the room is available for booking on that day. If the room is not available, you can offer other available dates or suggest another hotel that is available on the preferred date.","custom-prompt-fields#Custom Prompt Fields":"","entity---regex#Entity - Regex":"The Entity - Regex type of capture information uses regular expressions to extract specific patterns of information from the user's input and saves it in a variable of type String. It's particularly useful for capturing sensitive information like credit card numbers, which have distinct patterns.","steps-to-use-regex-field#Steps to use Regex Field":"Create a new entity in the Entities section of your Botpress instance with a custom regular expression that matches the pattern of the information you want to capture.\nCreate a new capture information card.\nSet the Type property to Entity Regex.\nSelect the entity you created in Step 1 from the Entity dropdown.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted information.\nSet the Prompt message property to a message that prompts the user to enter the information you want to capture.\n\nOnce the card is used, it will automatically extract the information that matches the regular expression pattern from the user's input and save it in the workflow variable you specified as a string. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's input.","example-22#Example":"Let's say you want to ask the user for their credit card number. You can create a new entity with a regular expression that matches the pattern of a credit card number, such as /(\\d-)\\d/ for a 16-digit credit card number in the format XXXX-XXXX-XXXX-XXXX. You can then create a new capture information card with the following properties:\n\nWhen the user enters their credit card number, the Entity Regex card will extract the credit card number that matches the regular expression pattern and save it in the creditCardNumber workflow variable as a string. You can then use this variable in other parts of your workflow to perform actions like validating the credit card number or sending it to a payment gateway.It's important to note that the Contains sensitive data property is available for Entity Regex type, which will mask the data by * before saving it in the database, making it more secure.","entity---list#Entity - List":"In this section, we'll discuss the Entity - List capture information type in Botpress. This type of capture information extracts specific pieces of information from the user's input based on matching it with entries (or synonyms) in a custom entity list. This can be useful when you want to capture specific information like a person's name, location, or product name.","steps-to-use-list-field#Steps to use List Field":"Create a new entity list under the library -> entities section.\nAdd entries to the entity list and their synonyms.\nCreate a new capture information card.\nSet the Type property to Entity List.\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted information.\nSet the Prompt message property to a message that prompts the user to enter information that matches the entity list.\n\nOnce the card is used, it will automatically extract the information that matches an entry (or one of its synonyms) in the custom entity list from the user's input and save it in the workflow variable you specified. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's response.","fuzzy-matching-options#Fuzzy matching options":"Botpress offers three options for fuzzy matching:\nStrict: No errors allowed.\nMedium: Tolerates up to one error in words of four characters or more.\nLoose: Tolerates up to two errors in words of four characters or more.\n\nThis means that even if the user makes a typo or a slight error, the system can still match the input with an entry in the entity list.","example-23#Example":"Let's say you want to ask the user for their favorite type of pizza. You can create a new entity list with entries like Pepperoni, Hawaiian, Margherita, and Vegetarian. Then, create a new capture information card with the following properties:\n\nWhen the user enters their response, the Entity List card will extract the information that matches an entry (or synonym) in the custom entity list and save it in the favoritePizza workflow variable. You can then use this variable in other parts of your workflow to make decisions or take actions based on the user's favorite pizza type.For example, you could use this variable to direct the user to the pizza ordering process, or to suggest additional toppings based on their selection.","advanced-configuration#Advanced Configuration":"","retries#Retries":"The Retries setting helps the bot handle situations when it doesn't understand what the user is saying. It allows the bot to ask the user to provide the information again in a different way. This can improve the user's experience with the bot, increase engagement, and help the bot handle more conversations before giving up.","number-of-retries#Number of retries":"This is the maximum number of times the bot will ask the user to provide the information again before giving up and sending the conversation to a failure transition.","retry-message#Retry message":"This is the message that the bot will show to the user each time they fail to answer the question. It will ask the user to provide the information again in a different way.","pro-tip#Pro Tip":"To give your users the best experience, you can combine the Retries option with the Add transition to handle failure flag. This will help the bot gracefully handle situations when it can't understand the user's input.","example-1-1#Example 1:":"Let's say you have a card that asks the user to choose between Food and Drinks. If you set the Number of retries to 0 and the Add transition to handle failure flag is turned on, then if the user says I want Cars, the bot will redirect the user directly to the failure transition, where you can show a message like Sorry, I didn't understand that.","example-2-1#Example 2:":"Now, let's change the example to have the Number of retries set to 2 and the Retry message set to Sorry, I didn't understand that, try to choose from the choices, and the Add transition to handle failure flag turned on. If the user says, I want Cars, the bot will respond with Sorry, I didn't understand that. Try to choose from the choices, and show the choices again.If the user provides another message that is not related to the choices, the bot will retry again, up to a maximum of 2 retries. If the user still fails to provide the required information after the maximum retries, the bot will redirect the user directly to the failure transition, where you can have a message like Sorry, I didn't understand that.","validation#Validation":"The Validation setting allows you to verify that the user's input meets certain criteria before proceeding with the conversation. This can help ensure that the information collected is accurate and relevant to the conversation.","properties#Properties":"","1-label#1. Label":"The label property allows you to generate validation code based on plain natural language instructions. This can make it easier to set up the validation rules without needing to write code.","2-code#2. Code":"If you prefer to write your own validation code, you can use the code property. This property allows you to write code to evaluate the user's input and determine whether it meets the validation criteria.","3-validation-failed-message#3. Validation failed message":"If the user's input fails validation, you can customise the message that the bot sends to inform the user of the validation failure.","steps-to-use-validation#Steps to use Validation":"To use the validation feature, you can add the validation properties to the Capture Information card in the Botpress interface. You can choose to use the Label or Code property to set up the validation rules.Once the validation rules are set up, the user's input will be evaluated before proceeding with the conversation. If the input meets the validation criteria, the conversation will continue normally. If the input fails validation, the bot will send a message with the validation failed message you have specified.","example-1-2#Example 1:":"Suppose you have a Capture Information card that asks the user for their age. You want to ensure that the user enters a number between 18 and 100. You can use the following validation code in the Validation section of the card:\n\nThis code first tries to parse the user's input as a number. If the input is not a valid number, the code returns false. Otherwise, it checks if the age is between 18 and 100 and returns true if it is.","example-2-2#Example 2:":"Suppose you have a Capture Information card that asks the user for their email address. You want to ensure that the user enters a valid email address format. You can use the following validation code in the Validation section of the card:\n\nThis code uses a regular expression to check if the user's input matches the format of a valid email address. If the input matches the format, the code returns true. Otherwise, it returns false.","extract-from-history#Extract from History":"The Extract from History setting allows the bot to extract values from previous messages in the conversation history. This can help the bot better understand the user's input and provide more accurate responses.","property#Property":"","number-of-messages-from-history-to-extract-from#Number of messages from history to extract from":"This property determines how many messages in the conversation history the bot will try to extract the value from. A value of 0 means that the bot will not look back in the conversation history and will only use the user's most recent message. A value of 1 means that the bot will extract the value from the user's previous message, and so on.","example-24#Example:":"Let's say you have a Capture Information card that asks the user for their favorite color. If the user has already mentioned their favorite color earlier in the conversation, you can use the Extract from History feature to extract the value from their previous message.If you set the Number of messages from history to extract from to 1, the bot will extract the value from the user's previous message. If you set it to 2, the bot will extract the value from the message before that, and so on.For example, if the user said My favorite color is blue earlier in the conversation and you set the Number of messages from history to extract from to 1, the bot will extract blue as the user's favorite color without asking the user again. This can save time and improve the user experience by avoiding repetitive questions.","cancellation#Cancellation":"The Cancellation setting can be used to break out of the conversation and cancel the Capture Information card. This can enhance the user's experience with the bot, making the conversation feel more natural and increasing engagement.","properties-1#Properties":"","user-can-cancel-the-capture#User can cancel the capture":"With this option turned on, users can cancel the Capture Information card at any time during the conversation.","confirm-before-cancelling#Confirm before cancelling":"If you turn on this option, users will be asked to confirm whether they want to cancel the Capture Information card before it is cancelled.","confirm-cancel-message#Confirm cancel message":"This option allows you to customise the message that the bot sends to confirm the user's decision to cancel the Capture Information card.","example-1-3#Example 1:":"Suppose you have a Capture Information card that asks the user for their name and email address. If the user decides to cancel the conversation, the User can cancel the capture option will allow them to do so easily.","example-2-3#Example 2:":"If you turn on the Confirm before cancelling option, the bot will ask the user if they are sure they want to cancel the Capture Information card before it is cancelled. If the user confirms the cancellation, the bot will send a message that you can customise using the Confirm cancel message option.","choices#Choices":"The Choices setting is used to offer a list of predefined options to the user as a response to a Capture Information card. This can be useful when you want to restrict the user's input to a specific set of values.\nTip\nChoices are only available for Single Choice & Multi Choice Prompt\ntypes.","example-25#Example":"Suppose you have a Capture Information card that asks the user to select their preferred mode of transportation - Car, Bus or Train. If you turn on the Choices option and specify these three options, the user will be presented with these options to choose from.","advanced#Advanced":"","1-add-transition-to-handle-failure#1. Add transition to handle failure":"This is a yes/no flag that determines whether a transition should be added to handle cases where the Capture Information card fails to retrieve information from the user.","example-26#Example":"If this flag is set to Yes and the Capture Information card fails to capture the required information, it will transition to the failure transition where a message can be displayed to the user, such as Sorry, I didn't understand that. Please try again.","2-skip-if-variable-is-already-filled#2. Skip if variable is already filled":"This is a flag that determines whether the Capture Information card should be skipped if the variable assigned to it already has a value.","example-27#Example":"If this flag is set to Yes and the variable already has a value, the Capture Information card will be skipped entirely, and the conversation will proceed to the next node.This flag can be useful in scenarios where a user may have already provided the required information in a previous conversation with the bot.Combining these two flags can help improve the user experience with the bot by allowing for smoother conversation flows and avoiding unnecessary repetition.","prompt-chaining#Prompt Chaining":"Prompt Chaining allows you to extract multiple values from a single user message using multiple Capture Information cards in sequence. If a value was not found, the respective Capture Information card will ask for its value.","chaining-multiple-prompts#Chaining Multiple Prompts":"To chain multiple Capture Information cards together, you need to follow these steps:\nAdd the first Capture Information card to the flow.\nSet the Type property to the type of information you want to capture (e.g., Fullname).\nSet the Variable name property to the name of the workflow variable you want to use to store the extracted information (e.g., fullname).\nSet the Prompt message property to a message that prompts the user to enter the information (e.g., Please enter your full name).\nSet the Extract from history property to 1.\nAdd the next Capture Information card to the flow.\nRepeat steps 1-6 for each additional Capture Information card you want to add, making sure to use a different variable name for each one.\n\nOnce the user enters a value, it will automatically extract the requested information from the user's message using each Capture Information card in sequence. If a value is not found for a particular Capture Information card, it will ask the user for the value before proceeding to the next node/card.You can then use the extracted variables in other parts of your flow by referencing the specific variable names using the following syntax: {{workflow.variableName}}.","example-28#Example":"Let's say you want to capture a user's full name, email address, and phone number. You can create a new flow with the following steps:\nAdd a Capture Information card to the flow with the following properties:\n\n\n\n\nAdd a second Capture Information card to the flow with the following properties:\n\n\n\n\nAdd a third Capture Information card to the flow with the following properties:\n\n\n\nWhen the user sends a message, the flow will begin extracting the requested information from the user's message using each Capture Information card in sequence. If a value is not found for a particular Capture Information card, it will ask the user for the value before proceeding to the next card.You can then use the extracted variables in other parts of your flow, such as sending a confirmation message to the user with their captured information:\n\nThis will display the user's captured information in a clear and easy-to-read format for both the user and the bot."}},"/cloud/webchat-customization/bot-information":{"title":"Show Bot Info","data":{"":"You can Customize the Chatbot's Information Page using below CSS\n\nTo show bot information page, you will need to add showBotInfoPage : true in\nyour webchat init object"}},"/cloud/toolbox/send-message":{"title":"Send Message","data":{"":"","send-message#Send Message":"You can Send Message using 8 built-in content-types. A Content-Type defines the structure of what the chatbot sends. It also dictates how your chatbot should render the content. It can be as straightforward or as complex as you want. For instance, a content type could be simple text or an image or a carousel.\nYou can add Content by dragging a Content Card over to a Standard Node.\n\n\n\n\nContent Types\n\nDescription\n\n\n\nText\n\nThe text content type denotes a regular text message with optional typing\nindicators. You can write HTML in the text content on the web channel, and\nyour chatbot will render it correctly. This opens up the possibility of\nincluding iFrames and constructing miniature web pages (commonly known as\nweb views) in your content without creating custom components.\n\n\n\nImage\n\nTo show an image with a title in the chat window, you can use the Image\ncontent type. Supported image formats are .tiff, .jpg, .png, .jpeg, .gif,\n.bmp, .tif.\n\n\n\nAudio\n\nAllows you to upload an mp3 audio file. The file will be playable within\nthe chat.\n\n\n\nVideo\n\nThe video content type presents a message showing a video file with a\ntitle.\n\n\n\nFile\n\nAllows you to upload any file that the user can download from the chat. In\naddition, you can add a title which will appear as a message under the\nfile.\n\n\n\nDropdown\n\nThe dropdown displays a list of options to the user. It includes a message\nto the user, and you can customize the dropdown placeholder text and the\ntext displayed on the selection button.\n\n\n\nCard\n\nA card is a message with a title and an optional subtitle. It also\ncontains an image and action buttons. Note that you first need to create\nthe action button separately.\n\n\n\nCarousel\n\nA carousel is an array of cards. This collection of cards can either be\npresented as a horizontally scrolling slide or a vertical message stack,\ndepending on the channel.\n\n\n\nChoice\n\nThis component carries a message, usually a question, and suggests choices\nto the user to fulfill the message in the form of buttons.\n\n\n\nLocation\n\nIt generates a message showing a location with an optional address and\ntitle. The required parameters to complete this content element are\nlongitude and latitude."}},"/cloud/toolbox/transition-to":{"title":"Transition to","data":{"":"A Transition is like a \"decision point\" in a conversation with a chatbot, where the bot has to decide what to do next based on what the user has said or done. It's like a set of instructions that the bot follows to determine which \"path\" to take in the conversation.\n\nFor example, if the user says something specific, the bot may need to ask a follow-up question or provide a certain response.The transition statement is what tells the bot which response or question to provide based on what the user has said or done.","expression#Expression":"An Expression transition is a conditional statement that tells the bot which node should be processed next if the condition is met. It uses generative AI to generate the conditions using plain text.\n\nThis type of transition allows you to check user input, user variables, workflow variables, and even create advanced JavaScript\nexpressions to determine which node the bot should transition to next.\n\nYou can use a combination of these checks to create complex conditions that will determine which node the bot will transition\nto next.\nGenerative AI Transitions\nYou can use generative AI to generate your conditions using plain text. In order to achieve what you exactly want,\nhere are some examples that should guide you, but you are not limited to it:\n\n\n\nExample\n\nDescription\n\n\n\nUser Input\n\nTo check if the user entered a value between 1 and 10, you can use User Input Example: user input is between 1 & 10\n\n\n\nUser Variable\n\nTo retrieve a value from the user variable, you can use user.{variable name}\nExample: user language is English\n\n\n\nWorkflow Variable\n\nTo check a workflows variable, you can use workflow.{variable name}\nExample: workflow variable supportEmail contains Botpress\n\n\n\nIntents\n\nYou can combine multiple checks together, for example you can check if an intent is of type \"affirmative\", and its confidence is more than 50%.\nExample: intent is affirmative and intent confidence is 50%\n\n\n\nAdvanced\n\nYou can use an advanced javascript expression to move from one node to the next when the expression satisfies the condition.","intent#Intent":"An Intent transition allows you to create an inline intent (or node-specific intent). Only if this intent is elected will the condition be met.\n\nThis type of transition is useful when you want to create a specific response for a particular intent. You can create an\nintent for a specific node, and the bot will transition to that node only if that intent is detected in the user's message.\n\nFor example, if a user says \"I want to book a hotel room,\" the bot can transition to a node that is specific to handling\nhotel room bookings."}},"/cloud/webchat-customization/chatbot-button":{"title":"Chatbot Button","data":{"":"You can Customize the Chatbot Button using below CSS\n\nThis class styles the floating button element\n\n\n\nTo add your own Icon as Chatbot Button, use this code\n\n\n\nThis class styles the icon inside the floating button\n\n\n\nThis class styles the notification badge on the floating button"}},"/cloud/webchat-customization/full-screen-bot":{"title":"Full Screen Chatbot","data":{"":"You can Customize the Chatbot to be Full Screen by default using below CSS"}},"/cloud/webchat-customization/header":{"title":"Chat Header","data":{"":"You can Customize the Chatbot Header using below CSS\n\n\nStyles the Header Icon\n\n\n\n\n\n\nStyles the Header Title & Subtitle\n\n\n\n\n\n\nMenu items. (Use these values in the init object)\n\n\n\n\nCustomization Variable\n\nVariable type\n\nDefault value\n\nDescription\n\n\n\nshowConversationsButton\n\nboolean\n\ntrue\n\nIf false, will hide the conversation list pane\n\n\n\nenableTranscriptDownload\n\nboolean\n\ntrue\n\nAllows the user to download the conversation history\n\n\n\nenableConversationDeletion\n\nboolean\n\nfalse\n\nAllows the user to delete its conversation history\n\n\n\nshowCloseButton\n\nboolean\n\ntrue\n\nDisplay's the web chat close button when the web chat is opened\n\n\n\n\n\nStyles the Header Container"}},"/cloud/webchat-customization/overview":{"title":"Overview","data":{"":"In this article, we will explore how to customize the behavior and appearance of the web chat. By default, the web chat comes with a set of pre-defined styles and options, but you can customize it to better suit your needs.","configuring-the-web-chat#Configuring the Web Chat":"You should select the Configurable option if you want to customize the web chat configuration.\n\n\nNote\nTo add your own CSS styling, you must upload your CSS file to your server and\nadd it's url to the stylesheet parameter.\n\n\nThe configuration object passed to the .init() accepts the following\navailable options which you can pass to customize the behavior of the web chat:\n\n\nCustomization Variable\tVariable type\tDefault value\tDescription\tstylesheet\tstring\t-\tProvide a path to a stylesheet to customize the web chat\tshowConversationsButton\tboolean\ttrue\tIf false, will hide the conversation list pane\tshowTimestamp\tboolean\tfalse\tIf true, will display a timestamp under each messages\tenableTranscriptDownload\tboolean\ttrue\tAllows the user to download the conversation history\tenableConversationDeletion\tboolean\tfalse\tAllows the user to delete its conversation history\tcloseOnEscape\tboolean\ttrue\tClose the web chat when pressing the Esc key\tbotName\tstring\t-\tDisplays the bot name to the right of its avatar\tcomposerPlaceholder\tstring\t'Reply to {botname}'\tAllows to set a custom composer placeholder\tavatarUrl\tstring\t-\tAllow to specify a custom URL for the bot's avatar\tlocale\tstring\t'browser'\tForce the display language of the web chat (en, fr, ar, ru, etc..)   Defaults to the user's browser language if not set Set to 'browser' to force use the browser's language\tbotConversationDescription\tstring\t-\tSmall description written under the bot's name\thideWidget\tboolean\tfalse\tWhen true, the widget button to open the chat is hidden\tdisableAnimations\tboolean\tfalse\tDisable the slide in / out animations of the web chat\tuseSessionStorage\tboolean\tfalse\tUse sessionStorage instead of localStorage, which means the session expires when tab is closed\tcontainerWidth\tstring\tnumber\t360\tSends an event to the parent container with the width provided\tlayoutWidth\tstring\tnumber\t360\tSets the width of the web chat\tenablePersistHistory\tboolean\ttrue\tWhen enabled, sent messages are persisted to local storage (recall previous messages)\tclassName\tstring\t-\tCSS class to be applied to iframe\tdisableNotificationSound\tboolean\tfalse\tIf true, chat will no longer play the notification sound for new messages.\tgoogleMapsAPIKey\tstring\t-\tGoogle Maps API Key required to display the map. It will display a link to Google Maps otherwise.\twebsite\tstring\t-\tDisplays the bot's website in the conversation page\tphoneNumber\tstring\t-\tDisplays the bot's contact phone number in the conversation page\ttermsConditions\tstring\t-\tDisplays the bot's terms of service in the conversation page\tprivacyPolicy\tstring\t-\tDisplays the bot's privacy policy in the conversation page\temailAddress\tstring\t-\tDisplays the bot's email address in the conversation page.\tcoverPictureUrl\tstring\t-\tDisplays the bot's cover picture in the conversation page\tshowBotInfoPage\tboolean\tfalse\tEnables the bot's information page in the web chat\tshowCloseButton\tboolean\ttrue\tDisplay's the web chat close button when the web chat is opened","styling-the-web-chat#Styling the Web Chat":"This CSS code includes styles for a chatbot widget\n\n\nClass Name\tDescription\t.bpw-layout\tSets the height, position, border, border-radius, and z-index of the chatbot widget.\t.bpw-header-title\tSets the font color of the chatbot header title to white.\t.bpw-from-bot .bpw-chat-bubble .bpw-chat-bubble-content\tSets the font color and background color of the chatbot message bubbles from the bot.\t.bpw-header-icon\tSets the fill color of the chatbot header icon to white when hovered over.\t.bpw-header-container\tSets the border, background color, and border radius of the chatbot header container.\t.bpw-header-title-container .bpw-bot-avatar\tHides the bot avatar in the chatbot header title container.\ta\tSets the font color of links in the chatbot widget to white and changes color to light gray when hovered over.\t.bpw-from-user .bpw-chat-bubble .bpw-chat-bubble-content\tSets the background color and border radius of the chatbot message bubbles from the user.\t#botpress-tooltip-1, #botpress-tooltip-37\tHides the tooltips for the chatbot widget.\t.bpw-send-button\tSets the appearance and position of the chatbot send button.\t.bpw-powered\tHides the powered by Botpress logo in the chatbot widget.\t.bpw-card-action\tSets the font weight, color, and border of the action buttons in the chatbot card carousel.\t.bpw-card-container\tSets the border of the chatbot card carousel.\t.bpw-keyboard-quick_reply\tSets the background color and padding of the chatbot quick reply buttons.\t.bpw-button\tSets the appearance and font of the chatbot quick reply buttons.\t.bpw-widget-btn\tSets the appearance and background image of the chatbot widget button.\t.bpw-floating-button\tRemoves the box shadow from the chatbot widget button.\n\n\nGo to next chapters to learn more about how to configure these classes."}},"/":{"title":"Index","data":{"":""}},"/cloud/webchat-customization/user-input":{"title":"User Input Area","data":{"":"You can Customize the User Input(text-area and send button) using below CSS"}},"/integration/cli":{"title":"CLI","data":{"":"The CLI is available as an npm package. It can be installed globally or locally.\n\nHere's the result of running bp --help:\n\nSince the bp bots and bp integrations commands are nested, you can run bp bots --help and bp integrations --help to see their respective subcommands.This is the result of running bp bots --help:\n\nThis is the result of running bp integrations --help:"}},"/integration/getting-started":{"title":"Getting Started","data":{"":"In this section, we'll create a simple integration that can send text messages to Telegram and a bot to try it out. This tutorial make use of both the Botpress CLI and the Botpress SDK.","setup#Setup":"Installing the Botpress CLI globally.","initialize-the-project#Initialize the project":"Create a new integration project using the init command. This will create a new folder with the name you specified and generate a basic project structure.","define-the-integration-and-generate-typings#Define the integration and generate typings":"Inside the file called integration.definition.ts add the following code:\n\nThere is a lot going on there, so let's break it down.","name-and-version#Name and version":"The name and version are used to identify the integration. The name is used to generate the integration ID, which is a unique identifier for the integration. The version is used to identify the version of the integration. For now, only one version of an integration can be deployed at a time and 0.0.1 is enforced.\nIntegration Names\nThe integration names are unique. If you try to create an integration with the same name as an existing one, the CLI will\nthrow an error.","configuration#Configuration":"The configuration is used to define the configuration schema of the integration. The schema is used to validate the configuration of the integration. The configuration is used to store sensitive information such as API keys and tokens. This configuration will be provided by the user when added the integration to his bot.","channels#Channels":"The channels are used to define which channels the integration supports. In this case, we defined a channel named group, this will be used to send messages to a specific group channel in telegram. The messages property is used to define the message types that the integration supports. For now, we will only implement the text message. The defaults object that comes from the SDK is used to define the default messages that the integration supports. We highly recommend implementing all message types provided by the SDK.","tags#Tags":"The tags are used to define the tags that the integration supports. In this case, we added a tag named id to the users, conversations and messages. Those tags will be used to identify the users, conversations and messages in the telegram system.","generate-typings#Generate typings":"The integration definition is used to generate typings for the integration. This will allow us to use the integration in our code without having to worry about the types.","implement-the-integration#Implement the integration":"Inside the folder src, there is a file called index.ts add the following code to it:\n\nOnce again, there is a lot going on there, so let's break it down.","register-and-unregister#Register and unregister":"The register and unregister functions are used to to manage the lifecycle of an integration. The register function is called when the integration is added to a bot and the unregister function is called when the integration is removed from a bot. The register function is used to setup the integration, in this case, we are setting up the webhook for telegram. The unregister function is used to clean up the integration, in this case, we are removing the webhook for telegram. Those functions should also be used to validate the configuration of the integration.","handler#Handler":"The handler function is used to handle the incoming requests from the integration. Which means that this function will be called every time the telegram integration sends a request to the webhook url set in the register function.In this case, we are parsing the incoming request from telegram and extracting the conversation id, user id and message id. Then, we are using those ids to create or retrieve the conversation, user and message from the botpress client. Finally, we are creating a message in the conversation. This message will be sent to the bot as an incoming message from telegram.","channels-1#Channels":"The channels object is used to implement the channels that the integration defined previously. In this case, we defined a channel named group, this will be used to send messages to a specific group channel in telegram. The text message type that we defined is implemented in the messages object. This function will be called every time the bot sends a text message to the group channel.","run-the-integration-in-dev-mode#Run the integration in dev mode":"Run the integration in dev mode:\n\nThis command will log an integration ID. Keep it, we'll need it later.Bravo! You've just created your first integration. Now that we have defined, implemented and started the integration, we should be able to send and receive text messages from a bot.","develop-the-bot#Develop the Bot":"","create-a-new-project-for-the-bot#Create a new project for the bot":"","add-the-integration-to-your-bot#Add the integration to your bot":"Now that we have a bot, we need to add the integration to it. To do so, we need to run the following command:\n\nThis command will add the integration to the bot. Once the integration is added, we need to configure it. Add the following code to the index.ts file in the src folder:\n\nNow that the integration is configured, we can add a little bit of code to the index.ts file to send a message to the group channel every time the bot receives a message from the user.\n\nWe have a parrot bot! Now, let's test it.","run-the-bot-in-dev-mode#Run the bot in dev mode":"Run the bot in dev mode:","iterate#Iterate":"At this point in time, you should have 4 different terminals running: one for the integration, one for the bot and two for ngrok.Both the integration and the bot are running locally within a process that watch source files for changes. This means that you can modify the integration and the bot and see the changes in real time.","deploy-the-integration#Deploy the Integration":"Now that we're happy with our integration, we can deploy it to the cloud. To do so, all we need to do is run the following command:\n\nThis command will deploy the integration to the cloud. Once the deployment is done, the integration will be available in the Integrations section of your workspace settings of the Botpress Cloud. You will also see this integration available in the Integrations tab of your bot.Congratulations! You've just created your first integration and deployed it to the cloud. Now, you can use this integration in any bot that you create in this workspace.For in depth documentation about the SDK, CLI and concepts continue to the next section"}},"/integration":{"title":"Botpress Cloud","data":{"":"This document aims to provide a comprehensive guide to the Botpress Cloud developer experience. After reading it, you should be able to create and manage Bots and Integrations using the CLI and SDK.","prerequisites#Prerequisites":"We assume that you are programmer that knows the JavaScript ecosystem and you already have a basic knowledge of Botpress. Among other things, the reader should:\nhave built at least one Chatbot with Botpress Cloud Studio\nbe comfortable with the command line (either Bash, Powershell or any other shell)\nbe familiar with Node.js\nbe familiar with TypeScript"}},"/integration/moving-parts":{"title":"Moving Parts","data":{"":"The standard way to develop a chatbot on Botpress Cloud is to use the Studio. It is a low-code platform; that is, the Studio allows you to create chatbots by writing little code, or even none at all.To please developers, Botpress Cloud also allows you to develop chatbots with code only. This set of features is called the developer side of Botpress Cloud or the developer experience (DX).In addition to allowing the development of Chatbots, the developer experience also allows the creation of Integrations. Integrations are applications that allow Chatbots to communicate with external services as well as share/reuse certain features. The only way to develop integrations is to do it with code.The developer experience is composed of the following parts:\nthe public HTTP API\nthe TypeScript HTTP Client\nthe TypeScript SDK\nthe CLI\n\nThe public HTTP API of Botpress Cloud is already documented here.The TypeScript HTTP Client, on the other hand, only exposes the API in an npm package to facilitate requests to the API in JavaScript and TypeScript. It contains all the types of requests and responses of the API.To create a Chatbot or an Integration, you must call the create-bot or create-integration route of the API. The HTTP body of the request contains a code field. This is the JavaScript program of the Bot or Integration. This code is executed by Botpress Cloud. However, this field cannot contain any program, it must have a certain format and a certain behavior for Botpress Cloud to be able to execute it. This is where the SDK comes in.The SDK is an npm package that is used and executed with the code of the Bot or Integration. It facilitates development by providing functions and classes that frame your development. It is theoretically possible to develop a Bot or an Integration without using the SDK, but this is strongly discouraged.At the time of writing, all Bots and Integrations are hosted and executed by Botpress Cloud. This means that it is not possible to host a server on your side. For this reason, the use of the JavaScript language is mandatory. If your program is written in TypeScript, it must be transpiled and bundled before being sent to Botpress Cloud. This is where CLI comes in.The CLI wears several hats. It allows you to interact with the public HTTP API of Botpress Cloud and to develop/deploy Bots and Integrations. Just like the SDK, it is theoretically possible to do without it but this is strongly discouraged.Since the public HTTP API of Botpress Cloud is already documented and the TypeScript HTTP Client only exposes it in an npm package, the next sections of this document will focus on the SDK and the CLI."}},"/integration/sdk":{"title":"Installation","data":{"":"The SDK is an npm package that can be installed with the following command:","chatbot-development#Chatbot Development":"The first step in developing a Bot with the SDK is to instantiate the Bot class as follows:\n\nThis is the minimal functional code that can be executed by Botpress as a Bot. It does absolutely nothing.To add behavior to the Bot, you can register a message handler as follows:\n\nThis handler will be called every time the Bot receives a message. It will then check the content of the message and send a response accordingly.The Bot's constructor is what we call its definition. It contains information such as the Bot's configuration or the type of events the Bot can receive. The message handler, on the other hand, is part of the Bot's implementation. The Bot's definition restricts its implementation and influences intellisense during development.The Bot's definition is described by the following fields:\ntagsThis field is used to specify the Tags used by the Bot.Tags are strings that allow to filter messages, conversations or users when querying the API.\nstatesThis field is used to specify the States used by the Bot.States are used to persist data in between a Bot's invocations.A State can be attached to a conversation, a user or can be global to the Bot.States have a schema, meaning that only the data that matches the schema can be persisted and retrieved.\nintegrationsThis field is used to specify the Integrations installed in the Bot.Integrations are used to connect a Bot to external services.Disabled Integrations are not used by the Bot. They can however be enabled later in the CDM or through the API.Setting an Integration in the Bot's definition does two things:\nit allows the Integration to call your Bot with events and messages.\nit allows your Bot to call the Integration with actions.\n\n\nconfigurationThis field is used to specify the schema of the Configuration provided to the Bot when it's called.The actual Configuration is provided by the user when deploying the Bot.\neventsThis field is used to specify the schema of the Events that can be sent to the Bot by Integrations.Events are just like messages, only they have a more general purpose, a custom schema and a wider use case.\nrecurringEventsThis field is used to specify Recurring Events.\nRecurring Events are events that are sent to the Bot following a certain cron schedule.\n\nHere's an example of a more complete Bot's definition:\n\nIn addition to the message handler, a Bot can also implement an event handler and an expired state handler as follows:","integration-development#Integration Development":"Integrations are developped in a similar fashion to Bots. The only difference is that there is 2 classes to instantiate: IntegrationDefinition and Integration wich stands for the Integration's implementation.This means that a typical Integration's code would require at least 2 files. Here's an example:\n\nThe implementation code is actually the one that must be transpiled and bundled to run in Botpress Cloud, but the definition contains fields that are required when creating the Integration with the API. The reason why the definition and the implementation are separated might be obscure for now, but it will become clearer when introducing the CLI and the generate command.Here's an example of a more complete Integration's definition with a proper implementation:\n\nThe Integration's definition is described by the following fields:\nnameThe name of the Integration. It must be unique accross all Integrations.\nversionThe version of the Integration. It must be unique accross all versions of the same Integration.Currently, only the version 0.2.0 is allowed for public Integrations and 0.0.1 for private Integrations. This is a temporary limitation that will be lifted in a near future.\npublicWhether the Integration is public or not. A public Integration can be installed by any Bot, while a private Integration can only be installed by Bots in the same workspace.\ntitleDisplay name of the Integration.\ndescriptionA description of the Integration.\niconPath to an SVG file containing the Integration's icon. This path can either be absolute or relative to the Integration's working directory.\nreadmePath to a Markdown file containing the Integration's documentation. This path can either be absolute or relative to the Integration's working directory.\ntagsA list of tags that can be used to filter users when querying the API.\nconfigurationThe configuration schema of the Integration. The actual configuration is provided by the bot when installing the Integration.\neventsA map of events that can be emitted by the Integration. Events can be used to trigger handlers in the Bot.\nactionsA map of actions that can be called by the Bot. Actions can be used to trigger handlers in the Integration. Actions are defined by their input and output schemas.\nchannelsA map of communication channels that can be used by the Bot send a message to the external service. Channels are defined by their messages types. The SDK provides a set of default messages types that can be used to send text, images, videos, etc.\nstatesJust like for Bots, Integrations can define states that can be used to store data. States are defined by their schema.\nuserAllows the Integration to proactively create a user. This is usefull if the Integration needs to send a message to a user that has not yet interacted with the Bot.\n\nThe Integration's implementation must implement handlers for the defition's actions and channels as well as a handler for the external service's requests. The first two handlers are called by the Bot when an action or a message is triggered. The last handler is called by the external service when an event is triggered."}},"/api-documentation":{"title":"Botpress API Documentation","data":{"":"","introduction#Introduction":"The Botpress API is a RESTful set of HTTP endpoints that allow you to create, deploy, and run chatbots on the Botpress Cloud.It can be used to create and manage bots, handle conversations and messages, as well as to manage their content, users, and configuration.The API endpoints will expect the Content-type: application/json HTTP header to be present in the request and  the request body (if any) to be in JSON format, and will send back the same header in the response and return a JSON response body as well.","authentication#Authentication":"To authenticate with the Botpress Cloud API, you'll need to use one of the methods below to obtain an access token.These tokens can be used as a Bearer token to call all the endpoints of the API, by passing the following HTTP header to the API endpoints:\n\n\nIdentity Token\n\nPersonal Access Token (PAT): Can be generated in the Profile Settings section of your Botpress Cloud account.\nBot Token: This will be provided to the bot (once deployed) in the BP_TOKEN environment variable.\nIntegration Token: This will be provided to the integration (once deployed) in the BP_TOKEN environment variable.","pagination#Pagination":"The \"List\" endpoints of our API will return paginated results based on the creation date of the resource, with a default limit of 20 results per page.When the number of results exceeds the limit, the response body will include a meta.nextToken property that can be passed as a query string parameter (e.g. endpoint?nextToken={nextToken}) to retrieve the next page of results.If there are no more results, the endpoint will not provide a nextToken value.\nExample:\n\nCall the /v1/chat/conversations endpoint to obtain the first page of results:\n\n\n\n\nCall the endpoint again but now passing the nextToken as a query string parameter, making sure the value is URL-encoded:\n\n\n\n\nRepeat until the response body doesn't provide a nextToken value anymore:","errors#Errors":"If an error occurs when calling an API endpoint, the response will return the appropriate HTTP status code\nas indicated below and the response body will be one of the following JSON objects indicating the nature\nof the error:\nUnknown\n\n\n\nInternal\n\n\n\nUnauthorized\n\n\n\nForbidden\n\n\n\nPayload Too Large\n\n\n\nInvalid Payload\n\n\n\nUnsupported Media Type\n\n\n\nMethod Not Found\n\n\n\nResource Not Found\n\n\n\nInvalid Json Schema\n\n\n\nInvalid Data Format\n\n\n\nInvalid Identifier\n\n\n\nRelation Conflict\n\n\n\nReference Not Found\n\n\n\nInvalid Query\n\n\n\nRuntime","user#User":"","the-user-object#The User object":"Attributes\n\nid : stringId of the User\n\ncreatedAt : stringCreation date of the User in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the User in the ISO 8601 format\n\ntags : map of objectsSet of Tags that you can attach to a User. The set of Tags available on a User is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","create-user#Create User":"Creates a new User. When creating a new User, the required tags must be provided. See the specific integration for more details.\nBody\n\ntags : map of objectsTags for the User\n\nintegrationName : stringName of the integration to which the user creation will be delegated\n\nResponse\nReturns a User object if creation succeeds. Returns an error otherwise\nuser : object (4)The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.\nid : stringId of the User\n\ncreatedAt : stringCreation date of the User in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the User in the ISO 8601 format\n\ntags : map of objectsSet of Tags that you can attach to a User. The set of Tags available on a User is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","get-user#Get User":"Retrieves the User object for a valid identifier.\nPath\n\nid : string\n\nResponse\nReturns a User object if a valid identifier was provided. Returns an error otherwise\nuser : object (4)The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.\nid : stringId of the User\n\ncreatedAt : stringCreation date of the User in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the User in the ISO 8601 format\n\ntags : map of objectsSet of Tags that you can attach to a User. The set of Tags available on a User is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","list-users#List Users":"Retrieves a list of User previously created. The users are returned in sorted order, with the most recent appearing first. The list can be filtered using Tags.\nQuery\n\nnextToken : string\n\nconversationId : string\n\ntags : object\n\nResponse\nReturns a list of User objects\nusers : array of object\nid : stringId of the User\n\ncreatedAt : stringCreation date of the User in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the User in the ISO 8601 format\n\ntags : map of objectsSet of Tags that you can attach to a User. The set of Tags available on a User is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","get-or-create-user#Get Or Create User":"Retrieves the User object for a valid identifier. If the user does not exist, it will be created.\nBody\n\ntags : map of objectsTags for the User\n\nintegrationName : stringName of the integration to which the user creation will be delegated\n\nResponse\nReturns a User object if a valid identifier was provided. Returns an error otherwise\nuser : object (4)The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.\nid : stringId of the User\n\ncreatedAt : stringCreation date of the User in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the User in the ISO 8601 format\n\ntags : map of objectsSet of Tags that you can attach to a User. The set of Tags available on a User is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","update-user#Update User":"Update a User object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.\nPath\n\nid : string\n\nBody\n\ntags : map of objectsTags for the User\n\nResponse\nReturns an updated User object if a valid identifier was provided. Returns an error otherwise\nuser : object (4)The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.\nid : stringId of the User\n\ncreatedAt : stringCreation date of the User in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the User in the ISO 8601 format\n\ntags : map of objectsSet of Tags that you can attach to a User. The set of Tags available on a User is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","delete-user#Delete User":"Permanently deletes a User. It cannot be undone.\nPath\n\nid : string\n\nResponse\nReturns the User object that was deleted","conversation#Conversation":"","the-conversation-object#The Conversation object":"Attributes\n\nid : stringId of the Conversation\n\ncreatedAt : stringCreation date of the Conversation in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Conversation in the ISO 8601 format\n\nchannel : stringName of the channel where the Conversation is happening\n\nintegration : stringName of the integration that created the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","create-conversation#Create Conversation":"Creates a new Conversation. When creating a new Conversation, the required tags must be provided. See the specific integration for more details.\nBody\n\nchannel : stringChannel name\n\ntags : map of objectsTags for the Conversation\n\nintegrationName : stringName of the integration to which the conversation creation will be delegated\n\nResponse\nReturns a Conversation object if creation succeeds. Returns an error otherwise\nconversation : object (6)The conversation object represents an exchange of messages between one or more users. A Conversation is always linked to an integration's channels. For example, a Slack channel represents a conversation.\nid : stringId of the Conversation\n\ncreatedAt : stringCreation date of the Conversation in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Conversation in the ISO 8601 format\n\nchannel : stringName of the channel where the Conversation is happening\n\nintegration : stringName of the integration that created the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","get-conversation#Get Conversation":"Retrieves the Conversation object for a valid identifier.\nPath\n\nid : string\n\nResponse\nReturns a Conversation object if a valid identifier was provided. Returns an error otherwise\nconversation : object (6)The conversation object represents an exchange of messages between one or more users. A Conversation is always linked to an integration's channels. For example, a Slack channel represents a conversation.\nid : stringId of the Conversation\n\ncreatedAt : stringCreation date of the Conversation in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Conversation in the ISO 8601 format\n\nchannel : stringName of the channel where the Conversation is happening\n\nintegration : stringName of the integration that created the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","list-conversations#List Conversations":"Retrieves a list of Conversation you’ve previously created. The conversations are returned in sorted order, with the most recent appearing first. The list can be filtered using Tags.\nQuery\n\nnextToken : string\n\ntags : object\n\nparticipantIds : array of string\n\nResponse\nReturns a list of Conversation objects\nconversations : array of object\nid : stringId of the Conversation\n\ncreatedAt : stringCreation date of the Conversation in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Conversation in the ISO 8601 format\n\nchannel : stringName of the channel where the Conversation is happening\n\nintegration : stringName of the integration that created the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","get-or-create-conversation#Get Or Create Conversation":"Retrieves the Conversation object for a valid identifier. If the conversation does not exist, it will be created.\nBody\n\nchannel : stringChannel name\n\ntags : map of objectsTags for the Conversation\n\nintegrationName : stringName of the integration to which the conversation creation will be delegated\n\nResponse\nReturns a Conversation object if a valid identifier was provided. Returns an error otherwise\nconversation : object (6)The conversation object represents an exchange of messages between one or more users. A Conversation is always linked to an integration's channels. For example, a Slack channel represents a conversation.\nid : stringId of the Conversation\n\ncreatedAt : stringCreation date of the Conversation in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Conversation in the ISO 8601 format\n\nchannel : stringName of the channel where the Conversation is happening\n\nintegration : stringName of the integration that created the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","update-conversation#Update Conversation":"Update a Conversation object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.\nPath\n\nid : string\n\nBody\n\ntags : map of objectsTags for the Conversation\n\nparticipantIds : array of stringIds of the [User]s(#schema_user) participating in the conversation\n\nResponse\nReturns an updated Conversation object if a valid identifier was provided. Returns an error otherwise\nconversation : object (6)The conversation object represents an exchange of messages between one or more users. A Conversation is always linked to an integration's channels. For example, a Slack channel represents a conversation.\nid : stringId of the Conversation\n\ncreatedAt : stringCreation date of the Conversation in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Conversation in the ISO 8601 format\n\nchannel : stringName of the channel where the Conversation is happening\n\nintegration : stringName of the integration that created the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","delete-conversation#Delete Conversation":"Permanently deletes a Conversation. It cannot be undone. Also immediately deletes corresponding Messages.\nPath\n\nid : string\n\nResponse\nReturns the Conversation object that was deleted","event#Event":"","the-event-object#The Event object":"Attributes\n\nid : stringId of the Event\n\ncreatedAt : stringCreation date of the Event in the ISO 8601 format\n\ntype : stringType of the Event.\n\npayload : map of objectsPayload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.","create-event#Create Event":"Creates a new Event. When creating a new Event, the required tags must be provided. See the specific integration for more details.\nBody\n\ntype : stringType of the Event.\n\npayload : map of objectsPayload is the content of the event defined by the integration installed on your bot or one of the default events created by our API.\n\nschedule : object (2)Schedule the Event to be sent at a specific time. Either dateTime or delay must be provided.\ndateTime : stringWhen the Event will be sent, in the ISO 8601 format\n\ndelay : numberDelay in milliseconds before sending the Event\n\n\nResponse\nReturns a Event object if creation succeeds. Returns an error otherwise\nevent : object (4)The event object represents an action or an occurrence.\nid : stringId of the Event\n\ncreatedAt : stringCreation date of the Event in the ISO 8601 format\n\ntype : stringType of the Event.\n\npayload : map of objectsPayload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.","get-event#Get Event":"Retrieves the Event object for a valid identifiers.\nPath\n\nid : string\n\nResponse\nReturns the Event object if a valid identifiers were provided. Returns an error otherwise\nevent : object (4)The event object represents an action or an occurrence.\nid : stringId of the Event\n\ncreatedAt : stringCreation date of the Event in the ISO 8601 format\n\ntype : stringType of the Event.\n\npayload : map of objectsPayload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.","list-events#List Events":"Retreives a list of Event you’ve previously created. The events are returned in sorted order, with the most recent appearing first.\nQuery\n\nnextToken : string\n\ntype : string\n\nResponse\nReturns a list of Event objects\nevents : array of object\nid : stringId of the Event\n\ncreatedAt : stringCreation date of the Event in the ISO 8601 format\n\ntype : stringType of the Event.\n\npayload : map of objectsPayload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","message#Message":"","the-message-object#The Message object":"Attributes\n\nid : stringId of the Message\n\ncreatedAt : stringCreation date of the Message in the ISO 8601 format\n\ntype : stringType of the Message represents the resource type that the message is related to\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\ndirection : stringDirection of the message (incoming or outgoing).\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","create-message#Create Message":"Creates a new Message. When creating a new Message, the required tags must be provided. See the specific integration for more details.\nBody\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntype : stringType of the Message represents the resource type that the message is related to\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.\n\nschedule : object (2)Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.\ndateTime : stringWhen the Message will be sent, in the ISO 8601 format\n\ndelay : numberDelay in milliseconds before sending the Message\n\n\nResponse\nReturns a Message object if creation succeeds.\nmessage : object (8)The Message object represents a message in a Conversation for a specific User.\nid : stringId of the Message\n\ncreatedAt : stringCreation date of the Message in the ISO 8601 format\n\ntype : stringType of the Message represents the resource type that the message is related to\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\ndirection : stringDirection of the message (incoming or outgoing).\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","get-or-create-message#Get Or Create Message":"Retrieves the Message object for a valid identifier. If the message does not exist, it will be created.\nBody\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntype : stringType of the Message represents the resource type that the message is related to\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.\n\nschedule : object (2)Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.\ndateTime : stringWhen the Message will be sent, in the ISO 8601 format\n\ndelay : numberDelay in milliseconds before sending the Message\n\n\nResponse\nReturns a Message object if a valid identifier was provided. Returns an error otherwise\nmessage : object (8)The Message object represents a message in a Conversation for a specific User.\nid : stringId of the Message\n\ncreatedAt : stringCreation date of the Message in the ISO 8601 format\n\ntype : stringType of the Message represents the resource type that the message is related to\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\ndirection : stringDirection of the message (incoming or outgoing).\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","get-message#Get Message":"Retrieves the Message object for a valid identifier.\nPath\n\nid : string\n\nResponse\nReturns a Message object if a valid identifier was provided. Returns an error otherwise\nmessage : object (8)The Message object represents a message in a Conversation for a specific User.\nid : stringId of the Message\n\ncreatedAt : stringCreation date of the Message in the ISO 8601 format\n\ntype : stringType of the Message represents the resource type that the message is related to\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\ndirection : stringDirection of the message (incoming or outgoing).\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","update-message#Update Message":"Update a message\nPath\n\nid : string\n\nBody\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.\n\nResponse\nMessage information\nmessage : object (8)The Message object represents a message in a Conversation for a specific User.\nid : stringId of the Message\n\ncreatedAt : stringCreation date of the Message in the ISO 8601 format\n\ntype : stringType of the Message represents the resource type that the message is related to\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\ndirection : stringDirection of the message (incoming or outgoing).\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.","list-messages#List Messages":"Retrieves a list of Messages you’ve previously created. The messages are returned in sorted order, with the most recent appearing first. The list can be filtered using Tags.\nQuery\n\nnextToken : string\n\nconversationId : string\n\ntags : object\n\nResponse\nReturns a list of Messages objects.\nmessages : array of object\nid : stringId of the Message\n\ncreatedAt : stringCreation date of the Message in the ISO 8601 format\n\ntype : stringType of the Message represents the resource type that the message is related to\n\npayload : map of objectsPayload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location\n\ndirection : stringDirection of the message (incoming or outgoing).\n\nuserId : stringID of the User\n\nconversationId : stringID of the Conversation\n\ntags : map of objectsSet of Tags that you can attach to a Conversation. The set of Tags available on a Conversation is restricted by the list of Tags defined previously by the Bot. Individual keys can be unset by posting an empty value to them.\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","delete-message#Delete Message":"Permanently deletes a Message. It cannot be undone.\nPath\n\nid : string\n\nResponse\nReturns the Message object that was deleted","file#File":"","the-file-object#The File object":"Attributes\n\nbotId : stringID of the bot the file will be used for\n\nname : stringOptional arbitrary file name (e.g. my-image.jpg), will be used for display purposes only.\n\naccessType : stringAccepted values: private, public\n\nid : stringID of the File\n\ncreatedAt : stringCreation date of the File in ISO 8601 format\n\nsize : numberSize of the file in bytes\n\npublicUrl : stringPublic URL to the file contents, available only if the access type is public. If the file is private, use the Download endpoint to retrieve the file contents.","create-file#Create File":"Create File\nBody\n\nbotId : stringID of the bot the file will be used for\n\ncontents : stringBase64-encoded file contents\n\nname : stringOptional arbitrary file name (e.g. my-image.jpg), will be used for display purposes only.\n\naccessType : stringAccepted values: private, public\n\nResponse\nSuccess\nfile : object (7)\nbotId : stringID of the bot the file will be used for\n\nname : stringOptional arbitrary file name (e.g. my-image.jpg), will be used for display purposes only.\n\naccessType : stringAccepted values: private, public\n\nid : stringID of the File\n\ncreatedAt : stringCreation date of the File in ISO 8601 format\n\nsize : numberSize of the file in bytes\n\npublicUrl : stringPublic URL to the file contents, available only if the access type is public. If the file is private, use the Download endpoint to retrieve the file contents.","get-file#Get File":"Get File\nPath\n\nid : string\n\nResponse\nSuccess\nfile : object (7)\nbotId : stringID of the bot the file will be used for\n\nname : stringOptional arbitrary file name (e.g. my-image.jpg), will be used for display purposes only.\n\naccessType : stringAccepted values: private, public\n\nid : stringID of the File\n\ncreatedAt : stringCreation date of the File in ISO 8601 format\n\nsize : numberSize of the file in bytes\n\npublicUrl : stringPublic URL to the file contents, available only if the access type is public. If the file is private, use the Download endpoint to retrieve the file contents.","download-file#Download File":"Download File\nPath\n\nid : string\n\nResponse\nRaw file contents","delete-file#Delete File":"Delete File\nPath\n\nid : string\n\nResponse\nSuccess","list-files#List Files":"List Files\nQuery\n\nnextToken : string\n\nbotId : string\n\nResponse\nSuccess\nfiles : array of object\nbotId : stringID of the bot the file will be used for\n\nname : stringOptional arbitrary file name (e.g. my-image.jpg), will be used for display purposes only.\n\naccessType : stringAccepted values: private, public\n\nid : stringID of the File\n\ncreatedAt : stringCreation date of the File in ISO 8601 format\n\nsize : numberSize of the file in bytes\n\npublicUrl : stringPublic URL to the file contents, available only if the access type is public. If the file is private, use the Download endpoint to retrieve the file contents.\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","state#State":"","the-state-object#The State object":"Attributes\n\nid : stringId of the State\n\ncreatedAt : stringCreation date of the State in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the State in the ISO 8601 format\n\nbotId : stringId of the Bot\n\nconversationId : stringId of the Conversation\n\nuserId : stringId of the User\n\nname : stringName of the State which is declared inside the bot definition\n\ntype : stringType of the State represents the resource type (conversation, user, bot or integration) that the state is related to\n\npayload : map of objectsPayload is the content of the state defined by your bot.","get-state#Get State":"Retrieves the State object for a valid identifiers.\nPath\n\ntype : string\n\nid : string\n\nname : string\n\nResponse\nReturns the State object if a valid identifiers were provided. Returns an error otherwise\nstate : object (9)The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.\nid : stringId of the State\n\ncreatedAt : stringCreation date of the State in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the State in the ISO 8601 format\n\nbotId : stringId of the Bot\n\nconversationId : stringId of the Conversation\n\nuserId : stringId of the User\n\nname : stringName of the State which is declared inside the bot definition\n\ntype : stringType of the State represents the resource type (conversation, user, bot or integration) that the state is related to\n\npayload : map of objectsPayload is the content of the state defined by your bot.","set-state#Set State":"Overrides the State object by setting the values of the parameters passed.\nPath\n\ntype : string\n\nid : string\n\nname : string\n\nBody\n\npayload : map of objectsPayload is the content of the state defined by your bot.\n\nexpiry : numberExpiry of the State in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.\n\nResponse\nReturns the updated State object if a valid identifier was provided. Returns an an error otherwise\nstate : object (9)The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.\nid : stringId of the State\n\ncreatedAt : stringCreation date of the State in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the State in the ISO 8601 format\n\nbotId : stringId of the Bot\n\nconversationId : stringId of the Conversation\n\nuserId : stringId of the User\n\nname : stringName of the State which is declared inside the bot definition\n\ntype : stringType of the State represents the resource type (conversation, user, bot or integration) that the state is related to\n\npayload : map of objectsPayload is the content of the state defined by your bot.","patch-state#Patch State":"Updates the State object by setting the values of the parameters passed.\nPath\n\ntype : string\n\nid : string\n\nname : string\n\nBody\n\npayload : map of objectsPayload is the content of the state defined by your bot.\n\nResponse\nReturns the updated State object if a valid identifier was provided. Returns an an error otherwise\nstate : object (9)The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.\nid : stringId of the State\n\ncreatedAt : stringCreation date of the State in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the State in the ISO 8601 format\n\nbotId : stringId of the Bot\n\nconversationId : stringId of the Conversation\n\nuserId : stringId of the User\n\nname : stringName of the State which is declared inside the bot definition\n\ntype : stringType of the State represents the resource type (conversation, user, bot or integration) that the state is related to\n\npayload : map of objectsPayload is the content of the state defined by your bot.","hub#Hub":"","list-public-integrations#List Public Integrations":"List public integration\nQuery\n\nnextToken : string\n\nname : string\n\nversion : string\n\nResponse\nSuccess\nintegrations : array of object\nid : stringId of the Integration\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","get-public-integration-by-id#Get Public Integration By Id":"Get public integration by Id\nPath\n\nid : string\n\nResponse\nSuccess\nintegration : object (16)\nid : stringId of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nuser : object (2)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\nreadmeUrl : stringURL of the readme of the integration. This is the readme that will be displayed in the UI","get-public-integration#Get Public Integration":"Get public integration by name and version\nPath\n\nname : string\n\nversion : string\n\nResponse\nSuccess\nintegration : object (16)\nid : stringId of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nuser : object (2)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\nreadmeUrl : stringURL of the readme of the integration. This is the readme that will be displayed in the UI","action#Action":"","call-action#Call Action":"Call an action\nBody\n\ntype : stringType of the action\n\ninput : map of objectsInput of the action\n\nResponse\nAction payload\noutput : map of objectsInput of the action","bot#Bot":"","the-bot-object#The Bot object":"Attributes\n\nid : stringId of the Bot\n\ncreatedAt : stringCreation date of the Bot in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Bot in the ISO 8601 format\n\nsigningSecret : stringSigning secret of the Bot\n\nintegrations : map of objects (6)A mapping of integrations to their configuration\nenabled : boolean\n\nname : string\n\nversion : string\n\nwebhookUrl : string\n\nconfiguration : map of objects\n\nstatus : string\n\n\nuser : object (1)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nconversation : object (1)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nstates : map of objects (3)A mapping of states to their definition\ntype : stringType of the State (conversation, user or bot)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\nexpiry : numberExpiry of the State in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.\n\n\nconfiguration : object (2)Configuration of the bot\ndata : map of objectsConfiguration data\n\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nevents : map of objects (1)Events definition\nschema : map of objects\n\n\nrecurringEvents : map of objects (3)Recurring events\nschedule : object (1)\ncron : string\n\n\ntype : string\n\npayload : map of objects\n\n\nname : stringName of the Bot\n\ndeployedAt : stringLast deployment date of the Bot in the ISO 8601 format\n\ndev : booleanIndicates if the Bot is a development bot; Development bots run locally and can install dev integrations\n\ncreatedBy : stringId of the user that created the bot\n\nmedias : array of objectMedia files associated with the Bot\nurl : stringURL of the media file\n\nname : stringName of the media file","create-bot#Create Bot":"Create bot\nBody\n\nstates : map of objects (3)A mapping of states to their definition\ntype : stringType of the State (conversation, user or bot)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\nexpiry : numberExpiry of the State in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.\n\n\nevents : map of objects (1)Events definition\nschema : map of objects\n\n\nrecurringEvents : map of objects (3)Recurring events\nschedule : object (1)\ncron : string\n\n\ntype : string\n\npayload : map of objects\n\n\nconfiguration : object (2)\ndata : map of objectsConfiguration data\n\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nuser : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nconversation : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\ncode : stringJavaScript code of the bot\n\nname : stringOptional name for the bot, if not provided will be auto-generated\n\nmedias : array of objectMedia files associated with the Bot\nurl : string\n\nname : string\n\n\nurl : stringURL of the Bot; Only available for dev bots\n\ndev : booleanIndicates if the Bot is a development bot; Development bots run locally and can install dev integrations\n\nResponse\nSuccess\nbot : object (17)\nid : stringId of the Bot\n\ncreatedAt : stringCreation date of the Bot in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Bot in the ISO 8601 format\n\nsigningSecret : stringSigning secret of the Bot\n\nintegrations : map of objects (6)A mapping of integrations to their configuration\nenabled : boolean\n\nname : string\n\nversion : string\n\nwebhookUrl : string\n\nconfiguration : map of objects\n\nstatus : string\n\n\nuser : object (1)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nconversation : object (1)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nstates : map of objects (3)A mapping of states to their definition\ntype : stringType of the State (conversation, user or bot)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\nexpiry : numberExpiry of the State in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.\n\n\nconfiguration : object (2)Configuration of the bot\ndata : map of objectsConfiguration data\n\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nevents : map of objects (1)Events definition\nschema : map of objects\n\n\nrecurringEvents : map of objects (3)Recurring events\nschedule : object (1)\ncron : string\n\n\ntype : string\n\npayload : map of objects\n\n\nname : stringName of the Bot\n\ndeployedAt : stringLast deployment date of the Bot in the ISO 8601 format\n\ndev : booleanIndicates if the Bot is a development bot; Development bots run locally and can install dev integrations\n\ncreatedBy : stringId of the user that created the bot\n\nmedias : array of objectMedia files associated with the Bot\nurl : stringURL of the media file\n\nname : stringName of the media file","update-bot#Update Bot":"Update bot\nPath\n\nid : string\n\nBody\n\nurl : stringURL of the Bot; Only available for dev bots\n\nauthentication : stringType of the Bot authentication (iam)\n\nconfiguration : object (2)\ndata : map of objectsConfiguration data\n\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nblocked : boolean\n\nuser : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nconversation : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nstates : map of objects (3)\ntype : stringType of the State (conversation, user or bot)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\nexpiry : numberExpiry of the State in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.\n\n\nrecurringEvents : map of objects (3)\nschedule : object (1)\ncron : string\n\n\ntype : string\n\npayload : map of objects\n\n\nintegrations : map of objects (2)\nenabled : boolean\n\nconfiguration : map of objects\n\n\ncode : stringJavaScript code of the bot\n\nname : stringOptional name for the bot, if not provided will be auto-generated\n\nmedias : array of objectMedia files associated with the Bot\nurl : string\n\nname : string\n\n\nResponse\nSuccess\nbot : object (17)\nid : stringId of the Bot\n\ncreatedAt : stringCreation date of the Bot in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Bot in the ISO 8601 format\n\nsigningSecret : stringSigning secret of the Bot\n\nintegrations : map of objects (6)A mapping of integrations to their configuration\nenabled : boolean\n\nname : string\n\nversion : string\n\nwebhookUrl : string\n\nconfiguration : map of objects\n\nstatus : string\n\n\nuser : object (1)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nconversation : object (1)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nstates : map of objects (3)A mapping of states to their definition\ntype : stringType of the State (conversation, user or bot)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\nexpiry : numberExpiry of the State in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.\n\n\nconfiguration : object (2)Configuration of the bot\ndata : map of objectsConfiguration data\n\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nevents : map of objects (1)Events definition\nschema : map of objects\n\n\nrecurringEvents : map of objects (3)Recurring events\nschedule : object (1)\ncron : string\n\n\ntype : string\n\npayload : map of objects\n\n\nname : stringName of the Bot\n\ndeployedAt : stringLast deployment date of the Bot in the ISO 8601 format\n\ndev : booleanIndicates if the Bot is a development bot; Development bots run locally and can install dev integrations\n\ncreatedBy : stringId of the user that created the bot\n\nmedias : array of objectMedia files associated with the Bot\nurl : stringURL of the media file\n\nname : stringName of the media file","transfer-bot#Transfer Bot":"Transfer bot to another workspace. You need to be a Manager member of the workspace the bot currently belongs to and have permission to create bots in the target workspace.\nPath\n\nid : string\n\nBody\n\ntargetWorkspaceId : stringThe ID of the workspace you want to transfer the bot to.\n\nResponse\nSuccess","list-bots#List Bots":"List bots\nQuery\n\nnextToken : string\n\nResponse\nSuccess\nbots : array of object\nid : stringId of the Bot\n\ncreatedAt : stringCreation date of the Bot in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Bot in the ISO 8601 format\n\nname : string\n\ndeployedAt : string\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","get-bot#Get Bot":"Get bot details\nPath\n\nid : string\n\nResponse\nSuccess\nbot : object (17)\nid : stringId of the Bot\n\ncreatedAt : stringCreation date of the Bot in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Bot in the ISO 8601 format\n\nsigningSecret : stringSigning secret of the Bot\n\nintegrations : map of objects (6)A mapping of integrations to their configuration\nenabled : boolean\n\nname : string\n\nversion : string\n\nwebhookUrl : string\n\nconfiguration : map of objects\n\nstatus : string\n\n\nuser : object (1)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nconversation : object (1)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nstates : map of objects (3)A mapping of states to their definition\ntype : stringType of the State (conversation, user or bot)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\nexpiry : numberExpiry of the State in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.\n\n\nconfiguration : object (2)Configuration of the bot\ndata : map of objectsConfiguration data\n\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nevents : map of objects (1)Events definition\nschema : map of objects\n\n\nrecurringEvents : map of objects (3)Recurring events\nschedule : object (1)\ncron : string\n\n\ntype : string\n\npayload : map of objects\n\n\nname : stringName of the Bot\n\ndeployedAt : stringLast deployment date of the Bot in the ISO 8601 format\n\ndev : booleanIndicates if the Bot is a development bot; Development bots run locally and can install dev integrations\n\ncreatedBy : stringId of the user that created the bot\n\nmedias : array of objectMedia files associated with the Bot\nurl : stringURL of the media file\n\nname : stringName of the media file","delete-bot#Delete Bot":"Delete bot\nPath\n\nid : string\n\nResponse\nSuccess","get-bot-logs#Get Bot Logs":"Get bot logs\nPath\n\nid : string\n\nResponse\nSuccess\nlogs : array of object\ntimestamp : string\n\nlevel : string\n\nmessage : string","get-bot-webchat#Get Bot Webchat":"Get the webchat code/URL for a bot\nPath\n\nid : string\n\nQuery\n\ntype : string\n\nResponse\nSuccess\ncode : string","get-bot-analytics#Get Bot Analytics":"Get bot analytics\nPath\n\nid : string\n\nQuery\n\nstartDate : string\n\nendDate : string\n\nResponse\nSuccess\nrecords : array of object\nstartDateTimeUtc : stringISO 8601 date string of the beginning (inclusive) of the period\n\nendDateTimeUtc : stringISO 8601 date string of the end (exclusive) of the period\n\nreturningUsers : number\n\nnewUsers : number\n\nsessions : number\n\nmessages : number","integration#Integration":"","the-integration-object#The Integration object":"Attributes\n\nid : stringId of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nuser : object (2)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\nreadmeUrl : stringURL of the readme of the integration. This is the readme that will be displayed in the UI","create-integration#Create Integration":"Create integration\nBody\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nuser : object (2)\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\ncode : stringJavaScript code of the integration\n\nurl : stringURL of the integration; Only available for dev integrations\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\nicon : stringBase64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.\n\nreadme : stringBase64 encoded markdown of the integration readme. The readme is specific to each integration versions.\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\nResponse\nSuccess\nintegration : object (16)\nid : stringId of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nuser : object (2)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\nreadmeUrl : stringURL of the readme of the integration. This is the readme that will be displayed in the UI","update-integration#Update Integration":"Update integration\nPath\n\nid : string\n\nBody\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\nmessage : object (1)\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nuser : object (2)\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\ncode : stringJavaScript code of the integration\n\nicon : stringBase64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.\n\nreadme : stringBase64 encoded markdown of the integration readme. The readme is specific to each integration versions.\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\nurl : stringURL of the integration; Only available for dev integrations\n\nResponse\nSuccess\nintegration : object (16)\nid : stringId of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nuser : object (2)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\nreadmeUrl : stringURL of the readme of the integration. This is the readme that will be displayed in the UI","list-integrations#List Integrations":"List integrations\nQuery\n\nnextToken : string\n\nname : string\n\nversion : string\n\nResponse\nSuccess\nintegrations : array of object\nid : stringId of the Integration\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\n\nmeta : object (1)\nnextToken : stringThe token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.","get-integration#Get Integration":"Get integration\nPath\n\nid : string\n\nResponse\nSuccess\nintegration : object (16)\nid : stringId of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nuser : object (2)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\nreadmeUrl : stringURL of the readme of the integration. This is the readme that will be displayed in the UI","get-integration-logs#Get Integration Logs":"Get integration logs\nPath\n\nid : string\n\nResponse\nSuccess\nlogs : array of object\ntimestamp : string\n\nlevel : string\n\nmessage : string","get-integration-by-name#Get Integration By Name":"Get integration\nPath\n\nname : string\n\nversion : string\n\nResponse\nSuccess\nintegration : object (16)\nid : stringId of the Integration\n\ncreatedAt : stringCreation date of the Integration in the ISO 8601 format\n\nupdatedAt : stringUpdating date of the Integration in the ISO 8601 format\n\nname : stringName of the Integration\n\nversion : stringVersion of the Integration\n\nconfiguration : object (1)Configuration definition\nschema : map of objectsSchema of the configuration in the JSON schema format. The configuration data is validated against this JSON schema.\n\n\nchannels : map of objects (3)\nmessages : map of objects (1)\nschema : map of objects\n\n\nconversation : object (2)Conversation object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the createConversation functionality to support this setting.\nenabled : booleanEnable conversation creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a conversation.\n\n\n\nmessage : object (1)Message object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\n\n\nstates : map of objects (2)\ntype : stringType of the State (conversation, user or integration)\n\nschema : map of objectsSchema of the State in the JSON schema format. This JSON schema is going to be used for validating the state data.\n\n\nevents : map of objects (1)\nschema : map of objects\n\n\nactions : map of objects (2)\ninput : object (1)\nschema : map of objects\n\n\noutput : object (1)\nschema : map of objects\n\n\n\nuser : object (2)User object configuration\ntags : map of objects (2)\ntitle : stringTitle of the tag\n\ndescription : stringDescription of the tag\n\n\ncreation : object (2)The user creation setting determines how to create a user through the API directly. The integration will have to implement the createUser functionality to support this setting.\nenabled : booleanEnable user creation\n\nrequiredTags : array of stringThe list of tags that are required to be specified when calling the API directly to create a user.\n\n\n\ndev : booleanIndicates if the integration is a development integration; Dev integrations run locally\n\ntitle : stringTitle of the integration. This is the name that will be displayed in the UI\n\ndescription : stringDescription of the integration. This is the description that will be displayed in the UI\n\niconUrl : stringURL of the icon of the integration. This is the icon that will be displayed in the UI\n\nreadmeUrl : stringURL of the readme of the integration. This is the readme that will be displayed in the UI","delete-integration#Delete Integration":"Delete integration\nPath\n\nid : string\n\nResponse\nSuccess","workspace#Workspace":"","the-workspace-object#The Workspace object":"Attributes\n\nid : string\n\nname : string\n\nownerId : string\n\ncreatedAt : string\n\nupdatedAt : string\n\nbotCount : number\n\naccountType : string\n\nblocked : boolean\n\nspendingLimit : number"}}}