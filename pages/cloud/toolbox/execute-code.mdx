import { Callout } from 'nextra/components'

# Execute Code

The Execute Code card allows you to execute code in the context of the current workflow. This is useful for making API calls, performing calculations, or any other custom logic you may need.

## How to Use

1. Write in the input what you want to achieve and press `Enter`
2. Check if the code satisfies your needs and Accept or Undo the changes
3. Once you accept, you can write instructions in the input to refine the code
4. Use the arrows to go back and forth between versions

<Callout>
  **Generative AI** <br />
  Using this natural language feature you can instruct AI to generate the different pieces of code your bot needs to run,
  and it's contextual, considers your variables and your conversation flow.
</Callout>

Example 1:

**"I want to find the difference between the variables startDate and the endDate"**

Generated Output:

```typescript
const startDate = luxon.fromISO(workflow.startDate) // convert the startDate string to a luxon DateTime object
const endDate = luxon.fromISO(workflow.endDate) // convert the endDate string to a luxon DateTime object
const diffInDays = endDate.diff(startDate, 'days').toObject().days // find the difference between the two dates in days
// store the difference in days in the workflow variable 'dateDiff' as requested
workflow.dateDiff = diffInDays
```

<br />
Example 2:

**"I want to get all my issues from Jira filtered by what is not done"**<br/>

Generated Output:

```typescript
const jiraUrl = 'https://your-jira-url.com'
const jiraUsername = 'your-jira-username'
const jiraPassword = 'your-jira-password'

// get the current date and time in ISO format
const now = luxon.local().toISO()

// create the JQL query to get all issues that are not done
const jql = `status != Done AND updated >= "${now}" ORDER BY updated DESC`

// set the request headers for Jira API
const headers = {
  'Content-Type': 'application/json',
  Authorization: `Basic ${btoa(`${jiraUsername}:${jiraPassword}`)}`,
}

// make the request to Jira API to get all issues that are not done
const response = await axios.get(`${jiraUrl}/rest/api/2/search?jql=${jql}`, { headers })

// filter the response to only keep the issues that are not done
const issues = _.filter(response.data.issues, (issue) => issue.fields.status.name !== 'Done')
```

<br />
#### Advanced

You can build your own code here, using below node packages:

- [Axios](https://axios-http.com/docs/api_intro)
- [Lodash](https://lodash.com/docs/4.17.15)
- [Moment Luxon](https://moment.github.io/luxon/#/?id=luxon)

Using the above packages, you will be able fetch and display the user-submitted city's weather information using an API.

#### Transitioning from Another Language to Botpress

If you're transitioning from another programming language to Botpress, we've got you covered. With the power of ChatGPT, converting simple code snippets, such as making API requests, is now easier than ever.

Step 1: Take your existing code from another programming language. This could be in a language like Python, C#, or any other language you're coming from.

Step 2: Paste the code snippet you have into ChatGPT and add this instruction below it.

```text
Convert the code above to deno. Save the variable results to the workflow object (global object available in the code block). Use axios for http requests and use it directly without the "async" keyword. For date management use the luxon library. For string manipulation use the lodash library. All of these libraries are already imported.
```

Step 3: Paste the result of ChatGPT into the Execute Code card.

Step 4: Test your code and make sure it works as expected.

Step 5: If you need to make any changes, you can do so by editing the code directly or by adding new instructions in the top input of the Execute Code card.
